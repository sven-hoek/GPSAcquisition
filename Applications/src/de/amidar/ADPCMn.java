package de.amidar;

/**
 * Adaptive differential pulse code mudulation.
 * 
 * This lossless audio codec is parameterized by
 *  - the prediction order M
 *  - the rice-coefficient K
 *  - the block size N (the overall number of sample needs not to devisible by N)
 * 
 * ### Data format ###
 * The sample format of the encoders input / decoders output can be configured by 
 *   - SAMPLE_BYTES      = number of bytes per sample, 
 *   - SAMPLE_BIG_ENDIAN = true, iff multi-byte samples are stored in big endian format
 *   - SAMPLE_SIGNED     = true, iff samples may be negative
 * 
 * @attention Code is tested for SAMPLE_BYTES=2, SAMPLE_BIG_ENDIAN=true, SAMPLE_SIGNED=true only!
 * 
 * ### Encoder ###
 * Each sample @f$x_i@f$ is predicted as linear combination 
 * @f$ p_i = \sum_{k=1}^M a_k x_{i-k} @f$ if M > 0 (adaptive prediction) or 
 * @f$ p_i = x_{i-1} @f$ if M = 0 (static prediction) respectively.
 * 
 * The prediction error @f$ e_i = x_i - p_i @f$ is mapped to a positive value 
 * @f$ u_i =  \left\{ \begin{array}{cl} 
 *            2 e_i,     & \text{for } e_i \geq 0 \\
 *           -2 e_i - 1, & \text{for } e_i < 0 
 *            \end{array}\right. @f$
 * preserving the property of small / large (absolute) values.
 *  
 * This value is finally passed through a RICE symbol encoder to generate 
 * the unary code of @f$ \frac{u_i}{2^K} @f$ and the 
 * K-bit binary code of @f$ u_i \bmod 2^K @f$.
 * 
 * The adaptive prediction coefficients @f$ a_k @f$ are optimized for each sample block (of size N) to achieve smallest 
 * prediction errors by
 *   - calculating the autocorrelation values @f$ c_k = \frac{1}{N-k} \sum_{i=1}^{N-k} x_i x_{i+k}, 0 \leq k \leq M @f$
 *   - solving the linear equation system
 *     @f$ \begin{pmatrix}
 *           c_0     & c_1     & c_2    & \cdots & c_{M-1} \\
 *           c_1     & c_0     & c_1    & \cdots & c_{M-2} \\
 *           \vdots  & \vdots  & \vdots & \ddots & \vdots  \\
 *           r_{M-1} & r_{M-2} & r_1    & \cdots & r_{0}
 *         \end{pmatrix} \cdot
 *         \begin{pmatrix}
 *           a_1     \\
 *           a_2     \\
 *           \vdots  \\
 *           a_{M}  
 *         \end{pmatrix} =
 *         \begin{pmatrix}
 *           c_1     \\
 *           c_2     \\
 *           \vdots  \\
 *           c_{M}  
 *         \end{pmatrix} @f$
 *                                                                                        
 * These coefficients are represented as signed fixed-point values (INTEGER+FRACTION bits) and written to the output
 * before acually encoding the sample block. For the static predictor (M=0), the block size parameter is ignored.
 *   
 * To initialize the predictor at the decoder, the first @f$ max(1,M) @f$ samples (of the first block) are written to 
 * the output in uncompressed binary block code.
 *   
 * ### Decoder ###
 * After reading the uncompressed initialization samples and the prediction coefficients at the beginning of each block, 
 * the decoder 
 *   - predicts @f$ p_i @f$ the same way as the encoder
 *   - restores @f$ u_i @f$ from the unary / binary input bits
 *   - maps     @f$ e_i =  \frac{1}{2} \left\{ \begin{array}{cl} 
 *                                             u_i,     & \text{for even } u_i\\
 *                                            -u_i - 1, & \text{for odd }  u_i \end{array}\right. @f$
 *   - restores @f$ x_i = p_i + e_i @f$ 
 * 
 * As the codec parameters (M,K,N) are not stored in the encoded bitstream, these have to be provided when calling the
 * decoder.
 *   
 * ### Hardware acceleration ###
 * The decoder and the static encoder (M=0) are single pass algorithms without complex computations. 
 * Therefore, hardware acceleration should focus on (higher order) adaptive encoding. The block size is limited by the
 * available memory and the applications end-to-end delay and should by statically choosen as large as possible. The
 * rice coefficient has to be optimized manually. In most application, a static selection for each data channel will be 
 * sufficient.
 * 
 * ### Usage examples ###
 * 
 * <pre>
 *              action inFile                 N  M  K  outFile                 show statistics
 *   java ADPCM encode channel1            2048  0  4  channel1.2048.00.04     verbose          # 1577 byte
 *   java ADPCM encode channel1            1024  9  4  channel1.1024.09.04     verbose          # 1525 byte
 *   java ADPCM decode channel1.2048.00.04 2048  0  4  channel1.2048.00.04.dec verbose          # must equal channel1
 *   java ADPCM decode channel1.1024.09.04 1024  9  4  channel1.1024.09.04.dec verbose          # must equal channel1
 * </pre>
 *   
 * @author Andreas Engel <engel@esa.cs.tu-darmstadt.de>
 * @date   11/2013
 */
public class ADPCMn {

	/*
	 * static configuration
	 **********************************************************************************************************************/

	static final int     SAMPLE_BYTES      = 2;     ///< number of bytes per sample
	static final boolean SAMPLE_BIG_ENDIAN = true;  ///< multi-byte samples are stored in big endian format?
	static final boolean SAMPLE_SIGNED     = true;  ///< samples may be negative?

	static final int     INTEGER           = 4;     ///< number of integer    bits for the prediction coefficients
	static final int     FRACTION          = 12;    ///< number of fractional bits for the prediction coefficients

	static final boolean ENCODE 	= true;
	static final boolean DECODE 	= false;

	/*
	 * command line support
	 **********************************************************************************************************************/

	/**
	 * Display usage and terminate.
	 */
	static int hhelp() {
		System.out.println(11);
		//System.out.println("usage: adpcm {encode|decode} <inFile> <blockSize> <order> <riceCoefficient> <outFile> [verbose]");
		//System.exit(-1);
		return 1;
	}

	/**
	 * Parse command line parameters and invoke encoder or decoder.
	 * @param args command line parameters
	 * This method also performs the File I/O and displays compression statistics.
	 */
	public static void main(String[] args) {
		run(14);
//		run(14);
	}

	/*
	 * Run the Test
	 */
	public static void run(int a){
		// check command line parameters
		//    if (args.length < 6) help();

		boolean 	action          = ENCODE;
		int     	blockSize       = 1024;
		int     	order           = a;
		int     	riceCoefficient = 4;
		//boolean verbose         = args.length > 6;

		// read inputFile
		// decodee order 14 input
			// 416
			//	int[] inBytes  = {27,-12,-30,-45,26,50,-24,-5,17,-29,-10,-62,3,-91,4,109,-14,-85,20,0,-23,-101,21,-37,-16,0,7,55,0,23,0,28,0,50,0,51,0,30,0,21,0,21,0,51,0,75,0,85,0,86,0,44,0,28,0,50,-121,15,53,-15,-13,35,-126,86,19,61,-60,69,-16,84,124,-122,-51,52,43,-83,113,33,-26,99,-94,-112,55,77,-93,-118,103,77,81,-96,70,-52,-110,64,117,24,-50,-55,-52,-98,79,-110,-106,72,-97,50,40,-24,31,0,99,96,-40,91,-110,63,65,34,-94,115,78,89,50,62,-97,-103,-9,73,-27,-28,-84,92,73,-14,116,76,-53,-82,50,-106,113,83,21,1,-96,102,53,16,22,34,-26,-44,-116,-111,35,5,99,-44,-73,33,-50,99,-95,37,85,72,-85,5,8,104,14,68,51,83,32,-114,-28,64,6,-8,-90,45,83,9,-126,103,21,80,96,-94,98,8,-38,-110,9,-102,-29,-59,-127,-104,32,65,9,-103,-122,81,-11,42,35,64,-82,44,-99,-66,-21,57,-82,-49,-51,78,-94,65,-79,-72,-71,83,16,-75,67,36,65,-32,66,-72,28,-67,-40,22,124,79,-121,18,-7,-76,-75,-48,-40,-98,9,52,100,-122,-87,8,-87,-52,86,65,9,37,123,-52,73,-18,-59,115,-32,-96,76,-63,102,77,8,-56,-20,-37,2,-83,80,14,-37,-68,-36,-72,83,127,48,104,-119,-8,19,20,14,-63,-100,-55,22,67,98,-126,60,-59,-93,-47,84,-14,-3,22,-28,-59,-97,-39,121,-22,-89,69,11,92,-128,61,9,-114,-104,-44,-95,102,-111,57,46,52,84,49,-109,2,108,23,113,60,-41,4,-46,-126,9,44,100,-58,57,70,-100,-120,-109,21,26,-114,-90,60,-56,96,-62,-125,-96,-47,84,-15,-40,-19,25,56,-78,11,52,-112,48,85,26,-115,18,106,-55,1,33,26,-55,18,-82,66,-92,86,8,-103,36,10,-30,-77,78,103,113,35,79,36,-13,13,89,-101,-117,106,25,14,75,-55,69,122,8,-82,-62,-101};
		
			// 1621
//			int[] inBytes = {16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 23, 0, 28, 0, 50, 0, 51, 0, 30, 0, 21, 0, 21, 0, 51, 0, 75, 0, 85, 0, 86, 0, 44, 0, 28, 0, 50, -97, -115, -58, -33, 103, -51, 118, 60, -77, -27, 54, -123, 91, -107, 21, 81, 3, -86, -81, -41, -53, -106, 46, -23, -126, -40, 69, 20, 10, -117, 85, -61, -49, -76, -30, 68, -41, 96, 5, 57, 112, -118, 42, 56, 55, 87, 79, -96, 127, 9, 71, -101, -96, 55, 71, -124, -4, 102, 3, 115, 16, -77, -43, -20, -108, 13, -7, 107, -106, -17, -59, 15, -114, -21, -126, 29, 115, -68, 62, 12, 21, 104, 26, 107, 74, -85, -122, -36, 47, 79, 54, -96, 18, -8, -24, -120, -53, -115, 88, -88, 10, 94, -71, -19, -78, 40, 72, 64, -120, 77, -74, 77, -112, 33, 56, -9, -33, -117, 5, -109, 78, -121, 79, 88, -24, 99, 103, 119, 2, -27, -71, 119, -123, 26, -78, 8, 3, 46, 26, -47, 50, -95, 74, 105, 108, -35, 89, 8, 75, 120, 103, -59, -60, 25, -19, 29, 6, 19, 11, -117, -101, -61, 111, 54, -52, 28, -6, 107, -89, -126, -20, -60, -15, -16, -10, -117, -39, -55, -118, 60, 113, -97, 116, 17, 108, -21, -89, 22, -3, -77, 73, 88, 112, 51, 15, 12, -80, 100, 86, 110, 33, -98, -36, 42, 1, -91, -46, -11, -30, -125, 10, -15, -33, 101, 64, 38, -50, 12, -8, -56, -13, 100, -59, 80, -21, 121, 38, -60, -55, -50, -86, -4, -91, -3, 68, -3, 123, 115, -47, -13, 115, 106, -33, -38, -48, 115, 32, 67, -7, -16, -86, -17, 36, 17, 95, -58, -125, -4, 95, -117, -33, -9, -44, 67, -22, 0, -45, -75, 32, -109, 49, 31, -122, 113, -110, -119, -4, 54, -117, 54, 76, -103, 53, -53, -88, 41, 17, 74, -110, -90, 46, 44, -119, -33, 104, 83, 42, 98, -70, -88, -127, 94, -5, -56, 43, -78, 0, -54, 98, -15, -122, 89, -28, 49, -31, -124, 32, -86, -25, 47, -92, -70, -82, -30, -32, 87, 14, -12, 12, -88, 18, 7, 6, 6, 80, -119, -9, -9, -38, -84, -36, 19, 6, -38, -43, 118, 5, 45, 53, -63, -85, -74, -3, 92, 86, 122, -17, 13, 120, -84, -56, 46, -100, 56, 77, 51, 44, -66, 16, -61, -110, 13, 90, -70, -15, 126, -123, -6, 114, -41, -68, 115, 16, -87, 61, -99, 14, 4, -67, 116, -29, -121, 21, -111, 1, 34, 68, -127, 92, 22, 15, 108, 37, -91, 25, 49, 76, -6, 70, -112, 93, -95, -110, -66, -100, 100, 112, -56, 41, -13, 127, 67, 127, -81, -83, 94, -22, 41, -110, -69, 120, 125, 60, -98, 109, -106, 78, 64, 85, -94, -14, 91, -23, -82, -34, -49, -24, -37, -8, -26, -63, 119, -120, 82, -31, -89, 19, -96, -96, -27, -57, 11, 5, -95, 71, -89, -50, -7, 38, -63, 8, -8, 38, -65, 108, -90, 32, -44, -23, 29, 110, 56, 79, 37, -50, -86, -30, -54, 81, 13, -29, 41, -32, 48, -79, 77, 13, 114, -53, 39, 18, 18, 96, 79, -100, -77, 104, -87, 111, 106, 74, 117, 6, 44, 84, -29, 21, -38, 34, 116, 74, 17, 76, 22, -96, 112, -128, -79, -62, -75, 58, 72, -122, -68, -23, 37, -70, -90, 84, 92, 117, 11, 60, -49, 1, -126, -52, -95, 94, -74, 97, -57, 93, 63, 119, 68, 14, -14, -109, -48, -2, -110, 76, -6, 61, -102, 47, -57, 109, 102, -116, 106, -116, 36, -127, 16, -60, -118, -49, 6, -86, -76, -25, 32, -85, 47, 22, -25, 13, 107, -91, 52, 72, 41, 101, -127, -61, 58, -86, 26, 106, -59, -121, 15, 83, 125, -79, -65, 102, -31, -43, 58, 65, -62, 72, 40, 127, 107, -117, 119, -60, -125, 111, -12, -102, 111, -85, -12, 118, -3, -74, 98, -94, 46, -65, 31, 77, -13, 100, -59, -105, -100, 50, -109, 100, -112, 75, 61, 120, -20, 25, -6, -86, 117, -116, -113, 75, -64, 69, 34, 70, 8, 109, 89, 78, -11, -85, 6, -115, 24, -105, -46, 60, 2, 50, 29, 49, -33, 94, 22, 96, -59, 32, -49, -105, -92, -72, -74, 72, 55, -58, 87, -122, 38, 50, 122, 96, 93, -15, -110, -87, 103, -63, 98, -108, -68, -16, -26, -43, 18, -105, -114, -9, 96, -111, 20, -37, 126, -99, 92, -44, -26, -12, 108, 95, -61, 46, 24, -4, 26, 34, -106, -102, -4, -70, 61, -106, 116, 29, 48, -14, -56, -119, -107, -17, 71, -126, -36, 124, 93, -124, 36, 83, -15, -60, -23, 118, 104, 4, -8, -57, 26, -71, -107, 63, 62, 87, 60, -78, 59, 87, 4, -115, -90, 22, -112, 103, -128, 73, 48, -27, 21, -62, -75, 85, 38, 119, -118, 28, 55, -18, -2, -27, -4, -8, 114, -26, -18, -47, -63, -113, -113, 40, 125, 23, 26, 92, 54, 22, 13, 2, -101, -89, -27, 124, -2, 47, -39, 127, 13, -116, 17, 117, -25, -38, 62, 73, -100, -102, -33, -76, -74, 73, 68, -72, 66, 77, 22, 69, 6, -4, 54, 84, -86, -92, 91, -86, 51, 109, 74, 75, 81, 33, 28, 82, 0, 76, 0, -94, 124, -30, 6, 91, -40, 115, 76, 6, 5, 26, 38, 46, 124, 47, 93, -50, 122, 8, 121, 117, -61, -55, -22, -112, 40, -53, -37, -57, 28, -43, 96, -51, 19, 113, -45, 92, 116, 93, 16, 94, -5, -15, -111, -124, -59, -28, -78, -15, 101, -4, -17, -125, -69, 118, 28, -58, -125, -72, 64, -108, 33, -15, -35, -39, 54, 77, 60, 123, 111, -52, 84, 35, -73, 119, -59, -113, -116, -15, -29, 38, 2, -23, 90, 32, -59, 36, 22, -12, -118, 10, -116, 87, 101, -115, 27, -57, 22, -103, -28, -71, 21, -54, 69, 50, 101, 105, -33, 88, -75, 118, 114, 23, 88, 8, -15, -119, -120, 30, 80, -7, -97, -83, -71, -9, 108, 55, 53, -68, -78, -69, -102, 24, -74, 53, 59, -43, -48, 16, -8, -2, -71, -51, -10, 124, 94, 28, -8, -95, -101, 69, -92, 70, -98, 48, -7, 35, -7, 115, -49, 87, 71, 39, -104, -110, -98, -73, 81, 98, 56, 65, -70, -121, 48, 109, 50, 28, -32, 64, 96, -90, -12, -43, 84, 69, -116, 51, -31, 76, 23, 57, 3, 25, 4, -118, -25, 67, 78, 98, 48, 37, 83, 90, -108, 88, -61, 55, 125, -29, -85, -109, -128, 115, -112, 16, 67, -15, -61, -109, 5, -64, 0, -93, -84, -7, 49, 30, -104, -58, -20, -38, -125, 123, -51, -40, -113, -99, -96, 125, -4, -69, -94, 55, 39, 7, 54, -97, -81, 92, -2, 47, 53, -54, -16, -14, -14, -45, -28, -39, 84, 63, 13, -34, -85, 120, -63, 9, -13, 104, -117, 47, 127, 104, -11, 100, -44, -67, 54, -49, -51, -40, 38, 6, 93, -71, -22, -71, 8, 93, 47, 120, -26, -20, -35, 60, -92, 85, -108, 57, 60, 57, 94, 10, -94, 126, -101, 84, 77, 61, 31, -30, -89, -100, 21, -44, -127, 110, 74, -54, 68, 79, -95, 127, 8, 96, -20, -39, 92, 25, -3, 119, -97, -10, 126, 15, 95, -74, 72, 24, 59, -49, 57, -72, -112, 35, -106, 61, -94, 2, 57, 33, -19, -113, 22, 99, -72, -100, -4, 119, -118, -20, -100, -106, 37, 40, -120, -109, -14, -42, -64, 6, 66, 70, -45, 6, 86, 88, 22, -64, -84, 48, -32, -47, 5, -3, -3, 122, -32, -20, -64, -39, 96, -126, 13, -124, 108, -108, 76, 87, -112, -27, 91, -63, 14, 26, 117, 121, 35, -68, -21, -93, -125, 18, -101, -65, 61, -111, 86, 88, -72, 54, 41, -71, 97, 96, -10, 35, -89, -125, -127, 62, 95, 124, -126, 77, 12, 21, -78, -41, 111, -101, -128, -62, -16, -29, 57, 52, 15, 117, -36, 61, 93, 92, -3, 35, 109, -79, 64, -7, 70, 124, 94, 67, -23, -57, -91, -32, -102, -95, 38, -79, 64, 121, -113, 121, 15, 25, -28, -28, -78, 3, 95, -100, 57, 51, 84, -58, -95, 21, -75, 97, 66, -51, 34, 11, -16, 126, 111, -73, -3, -66, 92, -68, -99, 95, 7, -63, -105, 110, 52, -18, 80, 47, -90, -53, 100, -14, 93, 102, -98, 29, 56, -1, 119, -55, -4, 63, -115, 19, 106, 7, 95, 15, 10, 54, 96, -22, 126, -12, 30, 50, -39, 35, 96, 44, 56, 46, -63, -121, -37, 103, -59, -52, 94, 91, -57, 52, 81, -121, 19, -106, -44, 1, 51, -29, -123, -40, 38, -110, -60, 36, 64, -66, -11, 3, 28, 97, 49, 103, -102, -59, -63, -93, -85, 67, 99, 24, -23, -62, -48, -88, -117, 26, 66, 58, -61, 54, -54, -102, 96, -58, 87, 58, -41, -22, -30, -32, -88, 70, 19, 113, -31, 51, -88, 34, -8, -95, -6, -51, 87, 99, -68, 101, -121, 23, -64, -126, 91, -53, 74, -13, 104, -55, 102, -97, 63, -108, -99, -46, 81, -113, -17, -125, -111, 33, -32, -112, 89, -127, -53, -98, -128, 86, -56, 21, -73, -98, 77, -102, 16, 88, 121, 78, -60, -39, 115, 34, 43, -46, 82, 42, 97, 86, 124, 80, 66, 9, 8, -69, 99, -85, 85, -49, -19, -31, 13, -121, -55, -6, -125, -45, -53, -73, 22, -116, 74, -27, -81, -105, 29, 75, 84, -128, 17, 123, 54, 127};
			
		
				
		// encode input
//		int [] inBytes = {0, 23, 0, 28, 0, 50, 0, 51, 0, 30, 0, 21, 0, 21, 0, 51, 
//				0, 75, 0, 85, 0, 86, 0, 44, 0, 28, 0, 50, 0, 38, 0, 12, 
//				0, 19, 0, 22, -1, -2, 0, 12, 0, 55, 0, 70, 0, 52, 0, 33, 
//				0, 21, 0, 2, 0, 5, 0, 25, 0, 30, 0, 15, -1, -4, 0, 0, 
//				0, 13, 0, 25, 0, 33, 0, 40, 0, 53, 0, 39, 0, 1, -1, -26, 
//				-1, -45, -1, -36, -1, -5, 0, 6, 0, 5, -1, -2, -1, -11, -1, -10, 
//				-1, -1, 0, 7, 0, 12, 0, 21, 0, 42, 0, 57, 0, 55, 0, 35, 
//				0, 12, 0, 8, 0, 9, 0, 13, 0, 24, 0, 39, 0, 55, 0, 55, 
//				0, 42, 0, 23, 0, 6, 0, 7, 0, 16, 0, 28, 0, 52, 0, 75, 
//				0, 61, 0, 48, 0, 84, 0, 82, 0, 41, 0, 38, 0, 36, 0, 55, 
//				0, 83, 0, 82, 0, 97, 0, 87, 0, 70, 0, 66, 0, 40, 0, 43, 
//				0, 43, 0, 36, 0, 55, 0, 57, 0, 54, 0, 42, 0, 55, 0, 93, 
//				0, 82, 0, 82, 0, 75, 0, 32, 0, 18, 0, 7, 0, 22, 0, 71, 
//				0, 62, 0, 28, 0, 43, 0, 58, 0, 57, 0, 56, 0, 34, 0, 22, 
//				0, 14, 0, 13, 0, 45, 0, 61, 0, 74, 0, 94, 0, 92, 0, 87, 
//				0, 73, 0, 68, 0, 73, 0, 59, 0, 50, 0, 35, 0, 18, 0, 10, 
//				0, 5, 0, 32, 0, 53, 0, 53, 0, 55, 0, 39, 0, 29, 0, 41, 
//				0, 50, 0, 53, 0, 47, 0, 37, 0, 42, 0, 59, 0, 71, 0, 70, 
//				0, 65, 0, 57, 0, 51, 0, 39, 0, 24, 0, 38, 0, 47, 0, 38, 
//				0, 40, 0, 42, 0, 41, 0, 42, 0, 43, 0, 36, 0, 21, 0, 31, 
//				0, 53, 0, 61, 0, 65, 0, 60, 0, 42, 0, 18, 0, 2, 0, 19, 
//				0, 35, 0, 49, 0, 60, 0, 48, 0, 52, 0, 59, 0, 47, 0, 33, 
//				0, 31, 0, 43, 0, 49, 0, 42, 0, 30, 0, 37, 0, 61, 0, 55, 
//				0, 44, 0, 59, 0, 53, 0, 37, 0, 36, 0, 40, 0, 61, 0, 79, 
//				0, 80, 0, 80, 0, 78, 0, 75, 0, 58, 0, 44, 0, 48, 0, 59, 
//				0, 64, 0, 55, 0, 50, 0, 45, 0, 32, 0, 25, 0, 36, 0, 65, 
//				0, 83, 0, 85, 0, 87, 0, 72, 0, 47, 0, 35, 0, 52, 0, 77, 
//				0, 76, 0, 64, 0, 49, 0, 47, 0, 59, 0, 62, 0, 63, 0, 69, 
//				0, 66, 0, 83, 0, 110, 0, 77, 0, 62, 0, 89, 0, 111, 0, 127, 
//				0, 99, 0, 78, 0, 64, 0, 51, 0, 75, 0, 90, 0, 109, 0, 111, 
//				0, 77, 0, 52, 0, 21, 0, 22, 0, 60, 0, 86, 0, 103, 0, 93, 
//				0, 75, 0, 65, 0, 61, 0, 84, 0, 92, 0, 101, 0, 123, 0, 93, 
//				0, 80, 0, 97, 0, 73, 0, 50, 0, 61, 0, 71, 0, 57, 0, 56, 
//				0, 72, 0, 78, 0, 61, 0, 36, 0, 25, 0, 33, 0, 51, 0, 56, 
//				0, 75, 0, 100, 0, 98, 0, 94, 0, 79, 0, 62, 0, 67, 0, 67, 
//				0, 70, 0, 59, 0, 38, 0, 30, 0, 24, 0, 41, 0, 49, 0, 32, 
//				0, 26, 0, 8, -1, -8, 0, 6, 0, 19, 0, 19, 0, 21, 0, 43, 
//				0, 67, 0, 47, 0, 29, 0, 31, 0, 23, 0, 26, 0, 44, 0, 61, 
//				0, 74, 0, 72, 0, 58, 0, 50, 0, 52, 0, 63, 0, 80, 0, 86, 
//				0, 74, 0, 70, 0, 75, 0, 61, 0, 26, 0, 23, 0, 76, 0, 78, 
//				0, 24, 0, 1, -1, -19, -1, -7, 0, 36, 0, 63, 0, 84, 0, 60, 
//				0, 29, 0, 22, 0, 22, 0, 49, 0, 53, 0, 54, 0, 52, 0, 8, 
//				-1, -9, -1, -4, 0, 11, 0, 45, 0, 53, 0, 62, 0, 46, 0, 20, 
//				0, 24, 0, 20, 0, 61, 0, 110, 0, 70, 0, 22, 0, 35, 0, 37, 
//				0, 33, 0, 54, 0, 54, 0, 52, 0, 47, 0, 24, 0, 19, 0, 19, 
//				0, 29, 0, 48, 0, 50, 0, 42, 0, 25, 0, 13, 0, 11, 0, 13, 
//				0, 25, 0, 13, -1, -20, -1, -35, -1, -34, -1, -15, 0, 3, 0, 21, 
//				0, 39, 0, 17, 0, 6, 0, 27, 0, 26, 0, 21, 0, 22, 0, 19, 
//				0, 16, 0, 11, 0, 8, 0, 3, 0, 12, 0, 37, 0, 55, 0, 50, 
//				0, 26, 0, 11, 0, 10, 0, 5, -1, -6, -1, -11, -1, -2, 0, 13, 
//				0, 26, 0, 35, 0, 35, 0, 21, -1, -3, -1, -19, -1, -17, -1, -16, 
//				-1, -1, 0, 17, 0, 17, 0, 20, 0, 25, 0, 31, 0, 25, 0, 7, 
//				0, 6, -1, -5, -1, -17, -1, -7, -1, -4, -1, -8, -1, -17, -1, -26, 
//				-1, -27, -1, -27, -1, -14, 0, 1, 0, 8, 0, 2, -1, -27, -1, -30, 
//				-1, -9, 0, 6, 0, 31, 0, 55, 0, 60, 0, 35, 0, 11, 0, 15, 
//				0, 13, 0, 10, 0, 14, 0, 15, 0, 19, 0, 17, 0, 25, 0, 41, 
//				0, 47, 0, 59, 0, 63, 0, 51, 0, 27, -1, -5, -1, -20, -1, -15, 
//				0, 4, 0, 28, 0, 39, 0, 38, 0, 23, 0, 9, 0, 14, 0, 29, 
//				0, 45, 0, 50, 0, 44, 0, 39, 0, 25, 0, 33, 0, 54, 0, 23, 
//				0, 7, 0, 28, 0, 53, 0, 67, 0, 29, 0, 13, 0, 12, -1, -2, 
//				0, 15, 0, 29, 0, 47, 0, 48, 0, 19, 0, 2, -1, -15, -1, -12, 
//				-1, -1, 0, 5, 0, 19, 0, 3, -1, -6, -1, -7, -1, -16, 0, 2, 
//				0, 10, 0, 31, 0, 52, 0, 22
//				};
		
		//2048
		int[] inBytes = {0, 23, 0, 28, 0, 50, 0, 51, 0, 30, 0, 21, 0, 21, 0, 51, 0, 75, 0, 85, 0, 86, 0, 44, 0, 28, 0, 50, 0, 38, 0, 12, 0, 19, 0, 22, -1, -2, 0, 12, 0, 55, 0, 70, 0, 52, 0, 33, 0, 21, 0, 2, 0, 5, 0, 25, 0, 30, 0, 15, -1, -4, 0, 0, 0, 13, 0, 25, 0, 33, 0, 40, 0, 53, 0, 39, 0, 1, -1, -26, -1, -45, -1, -36, -1, -5, 0, 6, 0, 5, -1, -2, -1, -11, -1, -10, -1, -1, 0, 7, 0, 12, 0, 21, 0, 42, 0, 57, 0, 55, 0, 35, 0, 12, 0, 8, 0, 9, 0, 13, 0, 24, 0, 39, 0, 55, 0, 55, 0, 42, 0, 23, 0, 6, 0, 7, 0, 16, 0, 28, 0, 52, 0, 75, 0, 61, 0, 48, 0, 84, 0, 82, 0, 41, 0, 38, 0, 36, 0, 55, 0, 83, 0, 82, 0, 97, 0, 87, 0, 70, 0, 66, 0, 40, 0, 43, 0, 43, 0, 36, 0, 55, 0, 57, 0, 54, 0, 42, 0, 55, 0, 93, 0, 82, 0, 82, 0, 75, 0, 32, 0, 18, 0, 7, 0, 22, 0, 71, 0, 62, 0, 28, 0, 43, 0, 58, 0, 57, 0, 56, 0, 34, 0, 22, 0, 14, 0, 13, 0, 45, 0, 61, 0, 74, 0, 94, 0, 92, 0, 87, 0, 73, 0, 68, 0, 73, 0, 59, 0, 50, 0, 35, 0, 18, 0, 10, 0, 5, 0, 32, 0, 53, 0, 53, 0, 55, 0, 39, 0, 29, 0, 41, 0, 50, 0, 53, 0, 47, 0, 37, 0, 42, 0, 59, 0, 71, 0, 70, 0, 65, 0, 57, 0, 51, 0, 39, 0, 24, 0, 38, 0, 47, 0, 38, 0, 40, 0, 42, 0, 41, 0, 42, 0, 43, 0, 36, 0, 21, 0, 31, 0, 53, 0, 61, 0, 65, 0, 60, 0, 42, 0, 18, 0, 2, 0, 19, 0, 35, 0, 49, 0, 60, 0, 48, 0, 52, 0, 59, 0, 47, 0, 33, 0, 31, 0, 43, 0, 49, 0, 42, 0, 30, 0, 37, 0, 61, 0, 55, 0, 44, 0, 59, 0, 53, 0, 37, 0, 36, 0, 40, 0, 61, 0, 79, 0, 80, 0, 80, 0, 78, 0, 75, 0, 58, 0, 44, 0, 48, 0, 59, 0, 64, 0, 55, 0, 50, 0, 45, 0, 32, 0, 25, 0, 36, 0, 65, 0, 83, 0, 85, 0, 87, 0, 72, 0, 47, 0, 35, 0, 52, 0, 77, 0, 76, 0, 64, 0, 49, 0, 47, 0, 59, 0, 62, 0, 63, 0, 69, 0, 66, 0, 83, 0, 110, 0, 77, 0, 62, 0, 89, 0, 111, 0, 127, 0, 99, 0, 78, 0, 64, 0, 51, 0, 75, 0, 90, 0, 109, 0, 111, 0, 77, 0, 52, 0, 21, 0, 22, 0, 60, 0, 86, 0, 103, 0, 93, 0, 75, 0, 65, 0, 61, 0, 84, 0, 92, 0, 101, 0, 123, 0, 93, 0, 80, 0, 97, 0, 73, 0, 50, 0, 61, 0, 71, 0, 57, 0, 56, 0, 72, 0, 78, 0, 61, 0, 36, 0, 25, 0, 33, 0, 51, 0, 56, 0, 75, 0, 100, 0, 98, 0, 94, 0, 79, 0, 62, 0, 67, 0, 67, 0, 70, 0, 59, 0, 38, 0, 30, 0, 24, 0, 41, 0, 49, 0, 32, 0, 26, 0, 8, -1, -8, 0, 6, 0, 19, 0, 19, 0, 21, 0, 43, 0, 67, 0, 47, 0, 29, 0, 31, 0, 23, 0, 26, 0, 44, 0, 61, 0, 74, 0, 72, 0, 58, 0, 50, 0, 52, 0, 63, 0, 80, 0, 86, 0, 74, 0, 70, 0, 75, 0, 61, 0, 26, 0, 23, 0, 76, 0, 78, 0, 24, 0, 1, -1, -19, -1, -7, 0, 36, 0, 63, 0, 84, 0, 60, 0, 29, 0, 22, 0, 22, 0, 49, 0, 53, 0, 54, 0, 52, 0, 8, -1, -9, -1, -4, 0, 11, 0, 45, 0, 53, 0, 62, 0, 46, 0, 20, 0, 24, 0, 20, 0, 61, 0, 110, 0, 70, 0, 22, 0, 35, 0, 37, 0, 33, 0, 54, 0, 54, 0, 52, 0, 47, 0, 24, 0, 19, 0, 19, 0, 29, 0, 48, 0, 50, 0, 42, 0, 25, 0, 13, 0, 11, 0, 13, 0, 25, 0, 13, -1, -20, -1, -35, -1, -34, -1, -15, 0, 3, 0, 21, 0, 39, 0, 17, 0, 6, 0, 27, 0, 26, 0, 21, 0, 22, 0, 19, 0, 16, 0, 11, 0, 8, 0, 3, 0, 12, 0, 37, 0, 55, 0, 50, 0, 26, 0, 11, 0, 10, 0, 5, -1, -6, -1, -11, -1, -2, 0, 13, 0, 26, 0, 35, 0, 35, 0, 21, -1, -3, -1, -19, -1, -17, -1, -16, -1, -1, 0, 17, 0, 17, 0, 20, 0, 25, 0, 31, 0, 25, 0, 7, 0, 6, -1, -5, -1, -17, -1, -7, -1, -4, -1, -8, -1, -17, -1, -26, -1, -27, -1, -27, -1, -14, 0, 1, 0, 8, 0, 2, -1, -27, -1, -30, -1, -9, 0, 6, 0, 31, 0, 55, 0, 60, 0, 35, 0, 11, 0, 15, 0, 13, 0, 10, 0, 14, 0, 15, 0, 19, 0, 17, 0, 25, 0, 41, 0, 47, 0, 59, 0, 63, 0, 51, 0, 27, -1, -5, -1, -20, -1, -15, 0, 4, 0, 28, 0, 39, 0, 38, 0, 23, 0, 9, 0, 14, 0, 29, 0, 45, 0, 50, 0, 44, 0, 39, 0, 25, 0, 33, 0, 54, 0, 23, 0, 7, 0, 28, 0, 53, 0, 67, 0, 29, 0, 13, 0, 12, -1, -2, 0, 15, 0, 29, 0, 47, 0, 48, 0, 19, 0, 2, -1, -15, -1, -12, -1, -1, 0, 5, 0, 19, 0, 3, -1, -6, -1, -7, -1, -16, 0, 2, 0, 10, 0, 31, 0, 52, 0, 22, 0, 39, 0, 91, 0, 85, 0, 48, 0, 29, 0, 15, -1, -9, -1, -11, 0, 0, 0, 2, -1, -1, -1, -6, -1, -10, 0, 4, 0, 32, 0, 39, 0, 39, 0, 28, -1, -2, -1, -15, -1, -33, -1, -42, -1, -25, -1, -11, -1, -2, -1, -2, -1, -7, -1, -6, -1, -2, 0, 8, 0, 7, 0, 1, 0, 9, 0, 23, 0, 21, -1, -2, -1, -11, -1, -14, -1, -27, -1, -23, -1, -5, 0, 12, 0, 23, 0, 15, 0, 2, 0, 0, -1, -5, -1, -5, 0, 10, 0, 30, 0, 36, 0, 25, 0, 17, 0, 4, -1, -14, -1, -12, -1, -5, -1, -7, -1, -5, -1, -4, -1, -16, 0, 3, 0, 63, 0, 56, -1, -6, -1, -36, -1, -31, 0, 8, 0, 20, 0, 7, 0, 17, 0, 3, -1, -12, -1, -37, -1, -74, -1, -48, -1, -13, 0, 9, 0, 23, 0, 11, 0, 13, 0, 13, 0, 26, 0, 46, 0, 30, 0, 32, 0, 17, -1, -20, -1, -34, -1, -49, -1, -19, 0, 41, 0, 18, -1, -32, -1, -21, -1, -5, 0, 10, 0, 43, 0, 44, 0, 33, 0, 16, 0, 3, 0, 20, 0, 27, 0, 35, 0, 47, 0, 43, 0, 40, 0, 22, 0, 13, 0, 19, 0, 20, 0, 40, 0, 45, 0, 41, 0, 28, -1, -8, -1, -16, -1, -6, 0, 5, 0, 21, 0, 12, 0, 10, 0, 34, 0, 45, 0, 29, 0, 6, -1, -5, -1, -2, 0, 0, -1, -2, 0, 3, 0, 10, 0, 20, 0, 27, 0, 12, -1, -6, -1, -15, -1, -19, -1, -9, 0, 6, 0, 13, 0, 26, 0, 41, 0, 38, 0, 27, 0, 24, 0, 25, 0, 23, 0, 15, 0, 13, 0, 10, 0, 6, 0, 14, 0, 17, 0, 18, 0, 35, 0, 46, 0, 37, 0, 23, 0, 12, 0, 1, 0, 11, 0, 36, 0, 40, 0, 35, 0, 38, 0, 38, 0, 26, 0, 6, 0, 3, 0, 14, 0, 34, 0, 47, 0, 41, 0, 33, 0, 26, 0, 21, 0, 18, 0, 14, 0, 19, 0, 18, 0, 27, 0, 44, 0, 31, 0, 13, 0, 14, 0, 29, 0, 49, 0, 58, 0, 65, 0, 74, 0, 79, 0, 80, 0, 77, 0, 80, 0, 79, 0, 72, 0, 76, 0, 74, 0, 65, 0, 65, 0, 62, 0, 52, 0, 43, 0, 37, 0, 42, 0, 49, 0, 59, 0, 68, 0, 66, 0, 60, 0, 40, 0, 35, 0, 37, 0, 22, 0, 43, 0, 54, 0, 59, 0, 68, 0, 42, 0, 55, 0, 56, 0, 36, 0, 47, 0, 39, 0, 39, 0, 42, 0, 41, 0, 47, 0, 28, 0, 27, 0, 21, -1, -1, 0, 5, -1, -12, -1, -30, -1, -44, -1, -57, -1, -10, 0, 18, 0, 26, 0, 33, -1, -2, 0, 0, 0, 36, 0, 28, -1, -1, 0, 1, 0, 12, 0, 4, 0, 16, 0, 54, 0, 74, 0, 58, 0, 40, 0, 25, 0, 11, 0, 14, 0, 4, 0, 2, 0, 7, -1, -3, -1, -4, -1, -2, 0, 6, 0, 10, 0, 1, 0, 10, 0, 14, 0, 0, -1, -4, 0, 4, 0, 25, 0, 38, 0, 17, -1, -3, -1, -1, 0, 0, -1, -14, -1, -17, 0, 8, 0, 31, 0, 38, 0, 36, 0, 30, 0, 24, 0, 11, 0, 6, 0, 18, 0, 28, 0, 29, 0, 18, 0, 7, 0, 15, 0, 22, 0, 20, 0, 16, 0, 21, 0, 34, 0, 32, 0, 27, 0, 40, 0, 57, 0, 40, 0, 23, 0, 52, 0, 45, 0, 6, -1, -4, -1, -12, 0, 10, 0, 33, 0, 31, 0, 44, 0, 32, 0, 27, 0, 27, 0, 2, 0, 4, 0, 12, 0, 24, 0, 16, -1, -15, -1, -8, -1, -11, 0, 4, 0, 45, 0, 49, 0, 52, 0, 28, -1, -9, -1, -6, 0, 5, 0, 50, 0, 102, 0, 71, 0, 24, 0, 38, 0, 55, 0, 67, 0, 76, 0, 46, 0, 12, -1, -17, -1, -33, -1, -22, -1, -4, 0, 13, -1, -6, -1, -34, -1, -35, -1, -46, -1, -44, -1, -22, -1, -12, -1, -4, -1, -15, -1, -27, -1, -41, -1, -59, -1, -45, -1, -47, -1, -51, -1, -22, -1, -9, -1, -2, 0, 12, 0, 18, 0, 8, -1, -13, -1, -21, -1, -21, -1, -19, -1, -14, -1, -10, 0, 0, 0, 6, 0, 7, 0, 5, -1, -2, -1, -8, -1, -11, -1, -15, -1, -23, -1, -29, -1, -24, -1, -8, 0, 12, 0, 32, 0, 49, 0, 43, 0, 14, 0, 12, 0, 28, 0, 29, 0, 32, 0, 36, 0, 43, 0, 54, 0, 50, 0, 42, 0, 28, 0, 11, 0, 17, 0, 33, 0, 50, 0, 60, 0, 58, 0, 54, 0, 35, 0, 6, 0, 3, 0, 20, 0, 42, 0, 52, 0, 50, 0, 42, 0, 32, 0, 29, 0, 21, 0, 20, 0, 29, 0, 35, 0, 41, 0, 29, 0, 16, 0, 24, 0, 18, 0, 2, -1, -8, -1, -6, 0, 7, -1, -4, -1, -16, 0, 0, 0, 14, 0, 19, 0, 24, 0, 18, -1, -2, -1, -11, 0, 8, 0, 29, 0, 38, 0, 43, 0, 37, 0, 19, 0, 3, 0, 10, 0, 26, 0, 36, 0, 40, 0, 27, 0, 12, -1, -4, -1, -25, -1, -4, 0, 23, 0, 10, 0, 29, 0, 65, 0, 87, 0, 81, 0, 40, 0, 29, 0, 12, 0, 2, 0, 34, 0, 54, 0, 63, 0, 52, 0, 39, 0, 25, -1, -10, 0, 10, 0, 48, 0, 62, 0, 90, 0, 86, 0, 81, 0, 72, 0, 45, 0, 55, 0, 59, 0, 70, 0, 75, 0, 35, 0, 39, 0, 71, 0, 56, 0, 38, 0, 63, 0, 93, 0, 95, 0, 97, 0, 106, 0, 94, 0, 68, 0, 77, 0, 84, 0, 73, 0, 95, 0, 115, 0, 115, 0, 103, 0, 85, 0, 83, 0, 73, 0, 78, 0, 105, 0, 110, 0, 98, 0, 70, 0, 51, 0, 58, 0, 50, 0, 47, 0, 57, 0, 64, 0, 85, 0, 109, 0, 119, 0, 112, 0, 99, 0, 90, 0, 83, 0, 85, 0, 83, 0, 79, 0, 87, 0, 88, 0, 83, 0, 86, 0, 84, 0, 73, 0, 74, 0, 89, 0, 90, 0, 75, 0, 80, 0, 93, 0, 88, 0, 76, 0, 68, 0, 69, 0, 60, 0, 43, 0, 27, 0, 50, 0, 113, 0, 107, 0, 63, 0, 46, 0, 27, 0, 46, 0, 77, 0, 97, 0, 121, 0, 103, 0, 77, 0, 58, 0, 57, 0, 93, 0, 108, 0, 111, 0, 100, 0, 83, 0, 97, 0, 94, 0, 102, 0, 122, 0, 123, 0, -122, 0, 105, 0, 62, 0, 54, 0, 42, 0, 75, 0, -127, 0, 113, 0, 88, 0, 102, 0, 108, 0, 109, 0, 106, 0, 84, 0, 64, 0, 41, 0, 39, 0, 65, 0, 76, 0, 83, 0, 78, 0, 64, 0, 56, 0, 33, 0, 30, 0, 44, 0, 54, 0, 66, 0, 55, 0, 38, 0, 37, 0, 39, 0, 59, 0, 73, 0, 82, 0, 90, 0, 66, 0, 49, 0, 63, 0, 76, 0, 81, 0, 94, 0, 104, 0, 98, 0, 105, 0, 118, 0, 121, 0, 114, 0, 99, 0, 94, 0, 89, 0, 86, 0, 99, 0, 101, 0, 92, 0, 90, 0, 99, 0, 109, 0, 109, 0, 110, 0, 116, 0, 116, 0, 117, 0, 126, 0, 118, 0, 106, 0, 107, 0, 107, 0, 88, 0, 72, 0, 78, 0, 74, 0, 77, 0, 88, 0, 88, 0, 94, 0, 93, 0, 97, 0, 117, 0, -128, 0, 125, 0, 105, 0, 88, 0, 80, 0, 74, 0, 89, 0, 96, 0, 88, 0, 92, 0, 94, 0, 90, 0, 79, 0, 57, 0, 48, 0, 74, 0, 111, 0, 121, 0, 120, 0, 124, 0, 105, 0, 74, 0, 48, 0, 38, 0, 49, 0, 62, 0, 78, 0, 97, 0, 106, 0, 99, 0, 81, 0, 68, 0, 54, 0, 44, 0, 56, 0, 71, 0, 80, 0, 79, 0, 71, 0, 63, 0, 47, 0, 29, 0, 31, 0, 37, 0, 39, 0, 56, 0, 90, 0, 104, 0, 88, 0, 89, 0, 70, 0, 18, 0, 10, 0, 18, 0, 49, 0, 72, 0, 55, 0, 74, 0, 77, 0, 85, 0, 116, 0, 117, 0, 117, 0, 106, 0, 105, 0, 104, 0, 70, 0, 85, 0, 115, 0, 126, 0, -112, 0, 123, 0, 97, 0, 74, 0, 58, 0, 77, 0, 74, 0, 78, 0, 82, 0, 51, 0, 74, 0, 115, 0, 97, 0, 71, 0, 67, 0, 57, 0, 39, 0, 41, 0, 57, 0, 54, 0, 33, 0, 27, 0, 31, 0, 39, 0, 56, 0, 66, 0, 74, 0, 59, 0, 30, 0, 31, 0, 39, 0, 52, 0, 55, 0, 52, 0, 59, 0, 40, 0, 30, 0, 34, 0, 10, 0, 8, 0, 17, -1, -4, -1, -16, -1, -6, 0, 9, 0, 13, -1, -1, -1, -12, -1, -10, -1, -5, 0, 1, 0, 12, 0, 17, -1, -4, -1, -28, -1, -42, -1, -41, -1, -20, 0, 10, 0, 36, 0, 33, 0, 11, 0, 11, 0, 13, 0, 5, 0, 3, 0, 4, 0, 10, 0, 14, 0, 12, -1, -7, -1, -8, 0, 27, 0, 19, -1, -3, -1, -10, -1, -30, -1, -7, 0, 15, 0, 18, 0, 45, 0, 30, 0, 3, -1, -8, -1, -1, 0, 26, 0, 17, 0, 26, 0, 48, 0, 41, 0, 36, 0, 12, 0, 17, 0, 45, 0, 44, 0, 43, 0, 9, -1, -37, -1, -49, -1, -46, 0, 0, 0, 41, 0, 8, -1, -12, 0, 5, -1, -4, 0, 7, 0, 27, 0, 12, 0, 14, 0, 18, -1, -3, -1, -29, -1, -30, 0, 4, -1, -6, -1, -49, -1, -69, -1, -81, -1, -68, -1, -40, -1, -14, 0, 21, 0, 23, 0, 12, 0, 8, -1, -6, 0, 1, 0, 13, 0, 27, 0, 31, 0, 6, 0, 6, 0, 29, 0, 41, 0, 48, 0, 54, 0, 52, 0, 45, 0, 48, 0, 52, 0, 59, 0, 66, 0, 66, 0, 74, 0, 77, 0, 76, 0, 71, 0, 55, 0, 50, 0, 63, 0, 76, 0, 85, 0, 82, 0, 72, 0, 71, 0, 59, 0, 42, 0, 37, 0, 45, 0, 60, 0, 67, 0, 71, 0, 69, 0, 67, 0, 69, 0, 70, 0, 74, 0, 60, 0, 48, 0, 52, 0, 45, 0, 41, 0, 44, 0, 46, 0, 52, 0, 51, 0, 48, 0, 53, 0, 46, 0, 39, 0, 34, 0, 38, 0, 52, 0, 58, 0, 61, 0, 54, 0, 30, 0, 14, 0, 12, 0, 25, 0, 51, 0, 75, 0, 73, 0, 61, 0, 63, 0, 63, 0, 71, 0, 62, 0, 20, 0, 11, 0, 29, 0, 45, 0, 60, 0, 60, 0, 60, 0, 61, 0, 51, 0, 37, 0, 33, 0, 51, 0, 68, 0, 64, 0, 51, 0, 41, 0, 39, 0, 46, 0, 65, 0, 86, 0, 85, 0, 69, 0, 61, 0, 64, 0, 94, 0, 98, 0, 54, 0, 47, 0, 47, 0, 39, 0, 23, -1, -4, 0, 19, 0, 28, 0, 31, 0, 57, 0, 81, 0, 108, 0, 87, 0, 41, 0, 19, 0, 7, 0, 40, 0, 75, 0, 90, 0, 95, 0, 62, 0, 35, 0, 8, -1, -5, 0, 29, 0, 51, 0, 64, 0, 55, 0, 14, 0, 29, 0, 66, 0, 51, 0, 25, 0, 25, 0, 16, 0, 12, 0, 31, 0, 51, 0, 60, 0, 41, 0, 9, -1, -22, -1, -24, -1, -3, 0, 15, 0, 36, 0, 30, 0, 9, -1, -6, -1, -18, 0, 9, 0, 39, 0, 40, 0, 46, 0, 45, 0, 34, 0, 11, -1, -9, 0, 4, 0, 19, 0, 23, 0, 27, 0, 21, 0, 8, 0, 0, -1, -8, -1, -10, 0, 1, 0, 31, 0, 54, 0, 42, 0, 31, 0, 33, 0, 38, 0, 52, 0, 64, 0, 71, 0, 66, 0, 41, 0, 22, 0, 14, 0, 14, 0, 27, 0, 36, 0, 28, 0, 7, -1, -8, -1, -3, -1, -1, -1, -22, 0, 6, 0, 71, 0, 58, 0, 30, 0, 30, 0, 16, 0, 29, 0, 33, 0, 34, 0, 57, 0, 52, 0, 46, 0, 43, 0, 45, 0, 49, 0, 37, 0, 57, 0, 51, 0, 10, 0, 9, 0, 17, 0, 47, 0, 69, 0, 55, 0, 63, 0, 43, 0, 5, -1, -11, -1, -15, 0, 39, 0, 87, 0, 49, 0, 10, 0, 20, 0, 28, 0, 34, 0, 32, 0, 16, 0, 12, 0, 0, 0, 3, 0, 28, 0, 32, 0, 33, 0, 29, 0, 26, 0, 16, -1, -7, -1, -6, -1, -6, -1, -2, 0, 24, 0, 15, -1, -16, -1, -26, -1, -9, 0, 10, 0, 6, 0, 13, 0, 15, -1, -13, -1, -39, -1, -55, -1, -54, -1, -39, -1, -21, 0, 5, 0, 19, 0, 14, 0, 9, 0, 13, 0, 22, 0, 24, 0, 12, -1, -15, -1, -29, -1, -23, -1, -23, -1, -24, -1, -14, -1, -12, -1, -22, -1, -29, -1, -26, -1, -27, -1, -38, -1, -32, -1, -18, -1, -19, -1, -26, -1, -18, -1, -13, -1, -30, -1, -39, -1, -23, -1, -3, 0, 5, -1, -11, -1, -43, -1, -73, -1, -95, -1, -87, -1, -57, -1, -41, -1, -48, -1, -59, -1, -51, -1, -43, -1, -35, -1, -13, -1, -11, -1, -18, -1, -8, 0, 4, 0, 15, 0, 12, 0, 4, 0, 6, 0, 2, -1, -1, -1, -7, -1, -15, -1, -15, -1, -24, -1, -41, -1, -54, -1, -33, 0, 1, -1, -9, -1, -25, -1, -29, -1, -35, -1, -23, 0, 1, 0, 18, 0, 23, 0, 16, -1, -8, -1, -28, -1, -14, -1, -5, -1, -19, -1, -22, -1, -13, 0, 11, 0, 33, 0, 38, 0, 31, 0, 12, 0, 3, 0, 9, 0, 7, 0, 29, 0, 33, 0, 4, 0, 28, 0, 52, 0, 47, 0, 12, -1, -28, -1, -18, -1, -17, -1, -22, -1, -10, -1, -4, -1, -3, -1, -18, -1, -29, -1, -43, -1, -58, -1, -23, 0, 1, 0, 4, 0, 5, -1, -28, -1, -46, -1, -50, -1, -48, -1, -28, -1, -30, -1, -7, 0, 8, -1, -17, 0, 12, 0, 41, 0, 13, -1, -16, -1, -18, -1, -25, -1, -40, -1, -31, -1, -23, -1, -31, -1, -42, -1, -44, -1, -48, -1, -31, 0, 3, -1, -1, -1, -22, -1, -40, -1, -61, -1, -69, -1, -69, -1, -58, -1, -45, -1, -44, -1, -49, -1, -63, -1, -62, -1, -54, -1, -58, -1, -47, -1, -51, -1, -67, -1, -65, -1, -69, -1, -79, -1, -83, -1, -73, -1, -47, -1, -33, -1, -25, -1, -22, -1, -38, -1, -58, -1, -59, -1, -41, -1, -22, -1, -9, -1, -3, -1, -10, -1, -6, -1, -2, -1, -16, -1, -23, -1, -29, -1, -30, -1, -26, -1, -32, -1, -29, -1, -19, -1, -15, -1, -18, 0, 22, 0, 73, 0, 26, -1, -45, -1, -80, -1, -99, -1, -73, -1, -44, -1, -4, 0, 36, 0, 17, -1, -6, -1, -24, -1, -29, -1, -6, -1, -1, -1, -1, -1, -17, -1, -30, -1, -16, -1, -31, -1, -21, 0, 13, 0, 28, 0, 42, 0, 21, -1, -4, -1, -25, -1, -43, 0, 12, 0, 54, -1, -3, -1, -53, -1, -49, -1, -38, -1, -17, -1, -17, -1, -47, -1, -72, -1, -97, -1, -93, -1, -71, -1, -55, -1, -26, -1, -34, -1, -58, -1, -54, -1, -58, -1, -68, -1, -71, -1, -57, -1, -47, -1, -54, -1, -46, -1, -49, -1, -58, -1, -42, -1, -27, -1, -11, -1, -28, -1, -67, -1, -53, -1, -12, 0, 15, 0, 12, -1, -15, -1, -31, -1, -33, -1, -22, -1, -13, -1, -23, -1, -24, -1, -7, 0, 0, -1, -6, -1, -13, -1, -9, -1, -9, -1, -14, -1, -26, -1, -44, -1, -53, -1, -46, -1, -30, -1, -19, -1, -9, 0, 5, 0, 9, 0, 4, 0, 5, 0, 5, -1, -11, -1, -27, -1, -22, -1, -22, -1, -40, -1, -50, -1, -51, -1, -48, -1, -51, -1, -63, -1, -52, -1, -38, -1, -44, -1, -36, -1, -16, 0, 13, 0, 33, 0, 26, 0, 16, 0, 14, 0, 12, -1, -1, -1, -18, -1, -25, -1, -26, -1, -21, -1, -19, -1, -25, -1, -27, -1, -32, -1, -33, -1, -35, -1, -49, -1, -50, -1, -39, -1, -17, -1, -4, -1, -11, -1, -8, -1, -9, -1, -19, -1, -22, -1, -15, -1, -8, -1, -23, -1, -31, -1, -10, 0, 15, 0, 39, 0, 52, 0, 53, 0, 56, 0, 57, 0, 50, 0, 32, 0, 15, 0, 18, 0, 25, 0, 37, 0, 39, 0, 33, 0, 58, 0, 49, 0, 3, 0, 6, 0, 19, 0, 49, 0, 56, 0, 22, 0, 19, 0, 10, 0, 27, 0, 67, 0, 71, 0, 73, 0, 58, 0, 31, 0, 18, 0, 12, 0, 31, 0, 51, 0, 69, 0, 83, 0, 62, 0, 26, -1, -9, -1, -7, 0, 24, 0, 34, 0, 46, 0, 28, -1, -20, -1, -12, 0, 14, 0, 9, 0, 8, 0, 32, 0, 42, 0, 43, 0, 62, 0, 62, 0, 35, 0, 15, 0, 27, 0, 27, 0, 13, 0, 19, 0, 27, 0, 32, 0, 9, -1, -19, -1, -9, 0, 13, 0, 33, 0, 37, 0, 34, 0, 25, -1, -2, -1, -6, 0, 0, -1, -5, 0, 9, 0, 24, 0, 30, 0, 39, 0, 36, 0, 28, 0, 23, 0, 20, 0, 22, 0, 27, 0, 38, 0, 39, 0, 25, 0, 21, 0, 38, 0, 46, 0, 37, 0, 37, 0, 47, 0, 49, 0, 43, 0, 28, 0, 18, 0, 31, 0, 52, 0, 67, 0, 59, 0, 28, 0, 3, 0, 2, 0, 16, 0, 12, 0, 30, 0, 83, 0, 82, 0, 53, 0, 26, 0, 3, 0, 20, 0, 40, 0, 57, 0, 62, 0, 35, 0, 21, -1, -6, -1, -24, -1, -11, -1, -17, -1, -12, -1, -2, -1, -2, -1, -1, -1, -4, 0, 26, 0, 48};
		
		
//		System.out.println("ASDFFF" + inBytes.length);

		int[] 	outBytes = new int[inBytes.length*10];
		int    outSize  = 0;
		
		AmidarSystem.invalidateFlushAllCaches();

		// invoke encoder/decoder
		if      (action == ENCODE) outSize = encode(inBytes, blockSize, order, riceCoefficient, outBytes);
		else if (action == DECODE) outSize = decode(inBytes, blockSize, order, riceCoefficient, outBytes);
		else hhelp();

//		System.out.println();
//		for(int i = 0; i < outBytes.length; i++){
//			System.out.print(outBytes[i]);
//			System.out.print(',');
//		}
//		System.out.println('\n');

		// write outputFile
		//    Files.write(Paths.get(outFile), java.util.Arrays.copyOf(outBytes, outSize));

		// report statistics
		//	if (verbose) {
		//      System.out.printf("%s %s [%d bytes] to %s [%d bytes] with blockSize=%4d order=%2d riceCoefficient=%2d\n",
		//        action, inFile,  inBytes.length,
		//                outFile, outSize,
		//                blockSize, order, riceCoefficient);
		//}
	}

	/*
	 * encoder
	 **********************************************************************************************************************/

	/**
	 * Invoke the encoder.
	 * @param inBytes         sample stream to be encoded
	 * @param blockSize       maximum number of samples to derive adaptive prediction parameters from
	 * @param order           prediction order (or 0 for first order static prediction)
	 * @param riceCoefficient parameter K for symbol coding
	 * @param outBytes        encoded bit stream
	 * @return size of encoded bit stream (in bytes)
	 */
	  static int encode(int[] inBytes, int blockSize, int order, int riceCoefficient, int[] outBytes) {
		    int     i;
		    int     sample             = 0;                               // current sample
		    int     samples            = 0;                               // number of already processed samples
		    int     inByte             = 0;                               // number of read input bytes
		    int     outByte            = 0;                               // number of written output bytes
		    byte    buffer             = 0;                               // bitbuffer for packing bitstream into bytes
		    int     bits               = 0;                               // number of valid bits in buffer
		    int     prediction         = 0;                               // sample prediction
		    int     error              = 0;                               // prediction error
		    int     ones;                                                 // run length of unary code (RICE)
		    boolean adaptivePass       = order > 0;                       // pass through samples to adopt coefficients
		    int[]   predictionHistory  = new int[order == 0 ? 1 : order]; // last samples used for prediction
		    int[]   correlationHistory = new int[order+1];                // last samples used for autocorrelation
		    int[]  correlationSum     = new int[order+1];               // accumulators for autocorrelation values
		    int[]   coefficients       = new int[order];                  // prediction coefficients
		    
		    // two different histories are required predict first sample of new block from last samples of old block after the
		    // new block was passed ones for autocorrelation
		    
		    int inBytesLength = inBytes.length;
		    int predictionHistoryLength = predictionHistory.length;
		    
		    int[] correlationValue = new int[order+1];       // autocorrelation values
	        int[] A                = new int[order*order];   // quadratic matrix of linear equation system
		    
		    while (inByte < inBytesLength) {
		      
		      // read next sample
		      sample = 0;
		      for (i=0; i<SAMPLE_BYTES; i++) {
		        if ((inByte < predictionHistoryLength * SAMPLE_BYTES) && !adaptivePass) outBytes[outByte++] = inBytes[inByte];
		        sample |= (inBytes[inByte++] & 0xFF) << ((SAMPLE_BIG_ENDIAN ? SAMPLE_BYTES-i-1 : i)*8);
		      }
		      if (SAMPLE_SIGNED && sample >= 1<<(SAMPLE_BYTES*8-1)) {
		        sample -= 1<<(SAMPLE_BYTES*8);
		      }
		      
		      // adapt coefficients to current block
		      if (adaptivePass) {
		      
		        // reset accumulators
		        if (samples == 0) {
		          for (i=0; i<=order; i++) correlationSum[i] = 0;
		        }
		        
		        // buffer sample for correlation
		        for (i=order; i>0; i--) correlationHistory[i] = correlationHistory[i-1]; 
		        correlationHistory[0] = sample;

		        // calculate (non normalized) autocorrelation values
		        for (i=0; i<=samples && i<=order; i++) {
		          correlationSum[i] += sample * correlationHistory[i];
		        }
		        
		        samples++;

		        // end of block reached?
		        if ((samples == blockSize) || (inByte == inBytesLength)) {
		          inByte      -= samples * SAMPLE_BYTES; // rewind input stream for second pass
		          adaptivePass = false;
		          
		          int   r,k;
		          int   abs, maxAbs      = 0;                      // used for numerical stability
//		          int[] correlationValue = new int[order+1];       // autocorrelation values
//		          int[] A                = new int[order*order];   // quadratic matrix of linear equation system
		          
		          // calculate autocorrelation values
		          for (i=0; i<=order; i++) {            
		            correlationValue[i] = (int) (correlationSum[i] / (samples-i));
		            abs = correlationValue[i] < 0 ? -correlationValue[i] : correlationValue[i];
		            if (abs > maxAbs) maxAbs = abs;
		          }
		          
		          // reduce values to 16bit (to avoid overflows in integer arithmetic)
		          while (maxAbs >= 1<<15) {
		            maxAbs /= 2;
		            for (i=0; i<=order; i++) correlationValue[i] >>= 1;
		            int dummy = 0;
		          }
		          
		          // derive linear equation system Ax=B from autocorrelation values, B[i]=correlationValue[i+1]
		          for (i=0; i<order; i++) {
		            for (k=0; k<order; k++) {
		              A[i*order+k] = correlationValue[i > k ? i-k : k-i];
		            }
		          }
		          
		          // solve linear equation system by gausian elimination (without pivot search) to calculate coefficients
		          for (i=0; i<order-1; i++) {
		            maxAbs = 0;
		            for (r=i+1; r<order; r++) {
		              for (k=i+1; k<order; k++) {
		                A[r*order+k] -= (A[r*order+i] * A[i*order+k]) / A[i*order+i];
		                abs = A[r*order+k];
		                if (abs < 0) abs = -abs;
		                if (abs > maxAbs) maxAbs = abs;
		              }
		              correlationValue[r+1] -= (A[r*order+i] * correlationValue[i+1]) / A[i*order+i];
		              abs = correlationValue[r+1];
		              if (abs < 0) abs = -abs;
		              if (abs > maxAbs) maxAbs = abs;
		              A[r*order+i] = 0;

		              // reduce values to 16bit
		              while (maxAbs >= 1<<15) {
		                maxAbs /= 2;
		                correlationValue[r+1]  >>= 1;
		                for (k=i+1; k<=order; k++) A[r*order+k] >>= 1;
		                int dummy = 0;
		              }
		            }
		          }

		          // backsubstitution
		          for (i=order; i-- != 0; ) {
		            coefficients[i] = correlationValue[i+1];
		            for (k=order-1; k>i; k--) coefficients[i] -= (A[i*order+k] * coefficients[k]) >> FRACTION;
		            coefficients[i] = (coefficients[i] << FRACTION) / A[i*order+i];

		            // fallback to simple dpcm if coefficients do not fit into fixedpoint format bits
		            abs = coefficients[i];
		            if (abs < 0) abs = -abs;
		            if (abs >= 1 << (INTEGER+FRACTION-1)) {
		              coefficients[0] = 1<<FRACTION;
		              for (k=1;k<order;k++) coefficients[k] = 0;
//		              System.err.println("AAAAAAAAAAAA");
//		              break;
		            }
		            int dummy = 1;
		          }

		          // write coefficients to output stream
		          for (k=0; k<order; k++) {
		            i = INTEGER+FRACTION;
		            while (i != 0) {
//		            	System.out.print(99);
		              if (i + bits >= 8) {
		                bits                = 8-bits;
		                i                  -= bits;
		                outBytes[outByte++] = (byte) ((buffer << bits) | (((1<<bits)-1) & (coefficients[k] >> i)));
		                bits                = 0;
		              } else {
		                bits  += i;
		                buffer = (byte) ((buffer << i) | (((1<<i)-1) & coefficients[k]));
		                i      = 0;
		              }
		              int dummy = 1;
		            }
		          }

		          samples = 0;
		        }
		      int dummy = 123;  
		      // predict sample and encode prediction error (except for the first unencoded samples)
		      } else {
		                
		        if (inByte > predictionHistoryLength * SAMPLE_BYTES) {
		        
		          // static/adaptive prediction
		          if (order == 0) {
		            prediction = predictionHistory[0];
		          } else {
		            prediction = 0;
		            for (i=0; i<predictionHistoryLength; i++) {
		              prediction += (predictionHistory[i] * coefficients[i]) >> FRACTION;
		            }
		          }

		          // prepare output of rice coder
		          error = sample - prediction;                 // prediction error
		          error = error >= 0 ? 2*error : -2*error-1;   // code spreading to positive values
		          ones  = error >> riceCoefficient;            // run length of unary code
		          error = error & ((1<<riceCoefficient)-1);    // residual for block code
		          
		          // write ones
		          while (ones != 0) {
		            if (ones + bits >= 8) {
		              bits                = 8-bits;
		              ones               -= bits;
		              outBytes[outByte++] = (byte) ((buffer << bits) | ((1<<bits)-1));
		              bits                = 0;
		            } else {
		              bits  += ones;
		              buffer = (byte) ((buffer << ones) | ((1<<ones)-1));
		              ones   = 0;
		            }
		            int dummy = 1;
		          }
		          
		          // write zero (to terminate unary code)
		          if (bits == 7) {
		            outBytes[outByte++] = (byte) (buffer << 1);
		            bits                = 0;
		          } else {
		            buffer <<= 1;
		            bits    += 1;
		          }
		          
		          // write residual block code
		          i = riceCoefficient;
		          while (i != 0) {
		            if (i + bits >= 8) {
		              bits                = 8-bits;
		              i                  -= bits;
		              outBytes[outByte++] = (byte) ((buffer << bits) | (((1<<bits)-1) & (error >> i)));
		              bits                = 0;
		            } else {
		              bits  += i;
		              buffer = (byte) ((buffer << i) | (((1<<i)-1) & error));
		              i      = 0;
		            }
		            int dummy = 1;
		          }
		        }

		        // buffer sample for next prediction
		        for (i=predictionHistoryLength-1; i>0; i--) predictionHistory[i] = predictionHistory[i-1]; 
		        predictionHistory[0] = sample;

		        // end of block reached?
		        if ((order > 0) && (samples == blockSize-1)) {
		          adaptivePass = true;
		          samples = 0;
		        } else {
		          samples++;
		        }
		      }
		      int dummy = 1;
		    }
		    
		    // 1-padding to full byte => avoids misinterpretation of padding as additional sample (unterminated unary code)
		    if (bits > 0) {
		      outBytes[outByte++] = (byte) (((buffer) << (8-bits)) | ((1<<(8-bits))-1));
		    }
		    
		    return outByte;
		  }

	/*
	 * decoder
	 **********************************************************************************************************************/

	/**
	 * Invoke the decoder.
	 * @param inBytes         bitstream to be decoded
	 * @param blockSize       maximum number of samples a set of adaptive prediction parameters is valid for
	 * @param order           prediction order (or 0 for first order static prediction)
	 * @param riceCoefficient parameter K for symbol coding
	 * @param outBytes        decoded byte stream
	 * @return size of decoded byte stream
	 */
	static int decode(int[] inBytes, int blockSize, int order, int riceCoefficient, int[] outBytes) 
	{
	    int   i=0, k=0;
	    int   sample       = 0;                                  // current sample
	    int   samples      = 0;                                  // number of already processed samples
	    int   inByte       = 0;                                  // number of read input bytes
	    int   outByte      = 0;                                  // number of written output bytes
	    int   prediction   = 0;                                  // sample prediction
	    int   error		=0;                                             // prediction error
	    int   bits         = 8;                                  // number of valid bits in current input byte
	    int[] lastSamples  = new int[order == 0 ? 1 : order];    // last samples used for prediction
	    int[] coefficients = new int[order];                     // prediction coefficients
	    
		int inBytesLength = inBytes.length;
		int lastSamplesLength = lastSamples.length;
		
		
//		System.out.println(999);
//		
//		System.out.println(888);
//		System.out.println(blockSize);
//		System.out.println(order);
//		System.out.println(riceCoefficient);
//		System.out.println(888);
//		System.out.println(i);
//		System.out.println(k);
//		System.out.println(sample);
//		System.out.println(samples);
//		System.out.println(inByte);
//		System.out.println(outByte);
//		System.out.println(prediction);
//		System.out.println(error);
//		System.out.println(bits);
//		System.out.println(888);
//		System.out.println(888);
//		System.out.println(inBytesLength);
//		System.out.println(lastSamplesLength);
//		
//		System.out.println(999);
//		System.out.println(outBytes.length);
	    
	    while (inByte < inBytesLength -2 ) {
	    	int dummy = 32767;
	    	
	      //read coefficients
	      if ((samples == 0) && (order > 0)) {
	        for (k=0; k<order; k++) {
	          coefficients[k] = 0;
	          i = INTEGER+FRACTION;
	          while (i != 0) {
//	        	  System.out.println("WHILE: " + i+ " bits: "+bits);
	            if (i >= bits) {
	              i -= bits;
	              coefficients[k] = (coefficients[k] << bits) | (((1<<bits)-1) & (inBytes[inByte] >> (8-bits)));
	              bits = 8;
	              inByte++;
//	              if (inByte == inBytes.length) return outByte;  // 1-padding of last encoded byte may lead us here
	            } else {
	              coefficients[k] = (coefficients[k] << i) | (((1<<i)-1) & (inBytes[inByte] >> (8-i)));
	              inBytes[inByte] <<= i;
//	              inBytes = inBytes;
	              bits -= i;
	              i     = 0;
	            }
	          }
	          if (coefficients[k] > (1<<(INTEGER+FRACTION-1))) {
	            coefficients[k] -= (1<<(INTEGER+FRACTION));
	          }
	        }
	      }
	      
	      
	      // read raw initialization sample
	      if (outByte < lastSamplesLength*SAMPLE_BYTES) {
	        sample = 0;
	        for (i=0; i<SAMPLE_BYTES; i++) {
//	        	System.out.println("writing (2) outbytes "+outByte+ " vale: "+inBytes[inByte] + " INBYTE: "+inByte);
	          outBytes[outByte++] = inBytes[inByte];
	          sample |= (inBytes[inByte++] & 0xFF) << ((SAMPLE_BIG_ENDIAN ? SAMPLE_BYTES-i-1 : i)*8);
	        }
	        if (SAMPLE_SIGNED && sample >= 1<<(SAMPLE_BYTES*8-1)) {
	          sample -= 1<<(SAMPLE_BYTES*8);
	        }
	        samples++;
	        lastSamples[lastSamplesLength-samples] = sample;
	      
	      // decode next sample
	      } else {
	        
	        // predict next sample
	        if (order == 0) {
	          prediction = lastSamples[0];
	        } else {
	          prediction = 0;
	          for (i=0; i<lastSamplesLength; i++) {
	            prediction += (lastSamples[i] * coefficients[i]) >> FRACTION;
	          }
	        }
	        
	        // decode prediction error
	        error = 0;
	        
	        // runlength of unary code
//	        System.out.println("inbyte " + inByte + " bytes: "+ inBytes[inByte] +" " + bits);
	        while ((inBytes[inByte] & 0x80) != 0) {
	          if (--bits == 0) {
	            bits = 8;
	            inByte++;
//	            if (inByte == inBytes.length) return outByte;  // 1-padding of last encoded byte may lead us here
	          } else {
	            inBytes[inByte] <<= 1;
	          };
	          error += 1;
	        };
	        
	        // skip terminating zero
	        if (--bits == 0) {
	          bits = 8;
	          inByte++;
	        } else {
	          inBytes[inByte] <<= 1;
	        };
	        
//	        System.out.println("err " + error);
	        
	        // read residual block code
	        i = riceCoefficient;
	        while (i != 0) {
//	        	System.out.println("OI");
	          if (i >= bits) {
	            i -= bits;
//	            System.out.println(" a "+ (error << bits) + " b " +(((1<<bits)-1) & (inBytes[inByte] >> (8-bits))));
	            error = (error << bits) | (((1<<bits)-1) & (inBytes[inByte] >> (8-bits)));
	            
	            bits = 8;
	            inByte++;
	          } else {
//	        	  System.out.println(" ae "+ (error << i) + " be " +(((1<<i)-1) & (inBytes[inByte] >> (8-i))));
//	        	  System.out.println("INBYTES + " + inBytes[inByte] + " ind " + inByte);
	            error = (error << i) | (((1<<i)-1) & (inBytes[inByte] >> (8-i)));
	            
	            inBytes[inByte] <<= i;
	            bits -= i;
	            i     = 0;
	          }
	        }
	        
	        // inverse spreading
//	        System.out.println("err + "+error);
	        error = ((error & 1) == 0) ? error>>1 : -((error+1)>>1);
	        
	        // calculate real sample
	        sample = prediction + error;
//	        System.out.println("pre: "+ prediction + "  err: "+ error);
	        samples++;
	        
	        // buffer sample for next prediction
	        for (i=lastSamplesLength-1; i>0; i--){ lastSamples[i] = lastSamples[i-1];} 
	        lastSamples[0] = sample;
	        
//	        System.out.println("SAMPLE: "+sample);
	        // output sample
	        for (i=0; i<SAMPLE_BYTES; i++) {
//	        	System.out.println("writing outBytes "+outByte+ " val: "+(sample >> ((SAMPLE_BIG_ENDIAN ? SAMPLE_BYTES-i-1 : i)*8)));
	          outBytes[outByte++] = (sample >> ((SAMPLE_BIG_ENDIAN ? SAMPLE_BYTES-i-1 : i)*8));
	        }
	        
	        // end of block?
	        if ((order > 0) && (samples == blockSize)) {
	          samples = 0;
	        }
	      }
//	      int dummy   = 1;
	    }
	    return outByte;
	  }
	}

/*
 * Copyright (c) 2013,
 * Embedded Systems and Applications Group,
 * Department of Computer Science,
 * TU Darmstadt,
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the
 * following conditions are met:
 * 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following
 *    disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the
 *    following disclaimer in the documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the institute nor the names of its contributors may be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
 * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 **********************************************************************************************************************/
