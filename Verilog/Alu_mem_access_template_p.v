/*
Author: Dennis L. Wolf
Date: 15.09.2015
Version: 1.1 (standard ALU with memory access  - autogenerated)
Version History: 1.1 debugged and simulated
		 1.0 layout & concept
*/
`timescale 1 ns / 1 ps

`include "definitions.vh" // import definitions of parameters and types

module Alu
(
  CLK_I,
  RST_N_I,
  EN_I,
  OPERAND_A ,
  OPERAND_B ,
  OPCODE_I ,
  PBOX_I,
  CONDITIONAL_I,
  RESULT_O ,
  CACHE_VALID_O,   
  CACHE_WRITE_O,   
  STATUS_O
  );
  
// PORTS:
input wire				CLK_I;
input wire				RST_N_I;
input wire 				EN_I;
input wire signed [`DATA_WIDTH-1:0]  	OPERAND_A;
input wire signed [`DATA_WIDTH-1:0]  	OPERAND_B;
input wire [`opH_pe-`opL_pe:0]		OPCODE_I;
input wire                		PBOX_I;
input wire				CONDITIONAL_I;
output wire signed [`DATA_WIDTH-1:0]	RESULT_O;
output wire				CACHE_VALID_O;   
output wire				CACHE_WRITE_O;   
output wire				STATUS_O;

// INTERNAL SIGNALS:
reg [`DATA_WIDTH-1:0] w_single_cycle_out;
reg [`DATA_WIDTH:0] r_multi_cycle_out;

reg w_single_cycle_operation,w_64_bit_operation;


reg [`DATA_WIDTH-1:0] a,b;

always@(posedge CLK_I) begin
 a <= OPERAND_A;
 b <= OPERAND_B;
end


reg [`DATA_WIDTH-1:0] operand_a_low,operand_a_high;
reg [`DATA_WIDTH-1:0] operand_b_low,operand_b_high;
wire [`DATA_WIDTH-1:0] result_low, result_high;


/////////////////////////////////////////////////////
// Counter for multicycle and 64-bit operations:
/////////////////////////////////////////////////////

reg [`ALU_COUNTER_WIDTH-1:0] r_counter;
reg w_reset_counter,r_carry,w_reminder;

always@(posedge CLK_I) begin 
  if(~RST_N_I) begin // rst
   r_counter <= 0;
   r_carry <=1'b0;
  end // rst
    else if(~EN_I) begin // en
     r_counter <= r_counter;
     r_carry <=r_carry;
    end // en
      else begin // normal mode
    if(w_reset_counter == 1'b0) begin
      r_counter <= r_counter + 1;
      end
    else begin
	  r_counter <= 0;
	  end	  
	if(w_reminder == 1'b1) begin
	   r_carry <= r_multi_cycle_out[`DATA_WIDTH];
	   end
	else begin
	   r_carry <= 1'b0;
	   end
	end // normal mode
end //clocked

// controlsignals for alu 

always@(*)begin
  case (OPCODE_I)
     `IADD:
 	begin
	 w_reset_counter = 1'b1;
	 w_single_cycle_operation = 1'b1;
	 w_64_bit_operation = 1'b0;
	end
     `ISUB: 
 	begin 
     	 w_reset_counter = 1'b1;
	 w_single_cycle_operation = 1'b1;
	 w_64_bit_operation = 1'b0;
	end
    `IMUL: 
 	begin 
         w_reset_counter = 1'b1;//(r_counter == `IMUL_duration-1) ? 1'b1 : 1'b0;
         w_single_cycle_operation = 1'b1;
         w_64_bit_operation = 1'b0;
     	end	   
     `IOR : 
 	begin 
       	 w_reset_counter = 1'b1;
	 w_single_cycle_operation = 1'b1;
	 w_64_bit_operation = 1'b0;
        end         
     `IAND: 
 	begin 
       w_reset_counter = 1'b1;
	   w_single_cycle_operation = 1'b1;
	   w_64_bit_operation = 1'b0;
               end
      `IXOR : 
 	begin 
      w_reset_counter = 1'b1;
      w_single_cycle_operation = 1'b1;
      w_64_bit_operation = 1'b0;
      end
      `ISHL : 
 	begin 
        w_reset_counter = 1'b1;
        w_single_cycle_operation = 1'b1;
        w_64_bit_operation = 1'b0;
                end        
        `ISHR : 
 	begin 
          w_reset_counter = 1'b1;
          w_single_cycle_operation = 1'b1;
          w_64_bit_operation = 1'b0;
                  end
        `IUSHR : 
 	begin 
        w_reset_counter = 1'b1;
        w_single_cycle_operation = 1'b1;
        w_64_bit_operation = 1'b0;
                end   
        `LADD :
 	 begin 
        if(r_counter[0] == 1'b1) 
             w_reset_counter = 1'b1;
        else
            w_reset_counter = 1'b0;
        w_single_cycle_operation = 1'b0;
        w_64_bit_operation = 1'b1;
                end  
        `LSUB :
 	 begin 
        if(r_counter[0] == 1'b1) 
             w_reset_counter = 1'b1;
        else
            w_reset_counter = 1'b0;
        w_single_cycle_operation = 1'b0;
        w_64_bit_operation = 1'b1;
                end                                                                             
        `DMA_LOAD:  
 	begin 
        w_reset_counter = 1'b1;
        w_single_cycle_operation = 1'b1;
        w_64_bit_operation = 1'b0;  
      end
      `DMA_STORE:  
 	begin 
              w_reset_counter = 1'b1;
              w_single_cycle_operation = 1'b1;
              w_64_bit_operation = 1'b0;   
            end
       `IFEQ: 
 	begin 
            w_reset_counter = 1'b1;
            w_single_cycle_operation = 1'b1;
            w_64_bit_operation = 1'b0;
           end
     `IFNE: 
 	begin 
            w_reset_counter = 1'b1;
            w_single_cycle_operation = 1'b1;
            w_64_bit_operation = 1'b0;
           end
     `IFGE: 
 	begin 
            w_reset_counter = 1'b1;
            w_single_cycle_operation = 1'b1;
            w_64_bit_operation = 1'b0;
           end
      `IFGT:
 	 begin 
          w_reset_counter = 1'b1;
          w_single_cycle_operation = 1'b1;
          w_64_bit_operation = 1'b0;
         end
       `IFLE: 
 	begin 
         w_reset_counter = 1'b1;
         w_single_cycle_operation = 1'b1;
         w_64_bit_operation = 1'b0;
        end
     `IFLT: 
 	begin 
            w_reset_counter = 1'b1;
            w_single_cycle_operation = 1'b1;
            w_64_bit_operation = 1'b0;
         end   
      `INEG: 
 	begin 
        w_reset_counter = 1'b1;
        w_single_cycle_operation = 1'b1;
        w_64_bit_operation = 1'b0;
     end      
     `NOP:
 	 begin
       w_reset_counter = 1'b1;
       w_single_cycle_operation = 1'b1;
       w_64_bit_operation = 1'b0;
       end
     default:
 	begin		
              w_reset_counter = 1'b1;
              w_single_cycle_operation = 1'b1;
              w_64_bit_operation = 1'b0;
             end 
  endcase
end


/////////////////////////////////////////////////////
// Register Management for 64-bit operations
/////////////////////////////////////////////////////


always@(posedge CLK_I)begin
  case (r_counter)
   0: if(w_64_bit_operation) begin
	operand_a_low <= a;
	operand_b_low <= b;
       end 
	else begin
	operand_a_high <= operand_a_high;
	operand_b_high <= operand_a_high;
       end
   1: if(w_64_bit_operation) begin
	operand_a_high <= a;
	operand_b_high <= b;
       end 
	else begin
	operand_a_high <= operand_a_high;
	operand_b_high <= operand_a_high;
       end
   default: begin
	operand_a_high <= operand_a_high;
	operand_b_high <= operand_a_high;
       end
  endcase
end

/////////////////////////////////////////////////////
// Combinatorial / 1-cycle operations:
/////////////////////////////////////////////////////

reg w_status;
assign STATUS_O = w_status;
reg w_enable_cache, w_write_cache;
assign CACHE_VALID_O = w_enable_cache;
assign CACHE_WRITE_O = w_write_cache;


always@(*) begin
  case (OPCODE_I)
    `IADD: 
 	begin 
    w_single_cycle_out =a+ b;
    w_status = 1'b0;
    w_enable_cache =1'b0;   
    w_write_cache  =1'b0;   
     end
    `ISUB: 
 	begin 
    w_single_cycle_out =a- b;
    w_status = 1'b0;
    w_enable_cache =1'b0;   
        w_write_cache  =1'b0;   
    end
    `IMUL: 
 	begin 
    w_single_cycle_out =a* b;
    w_status = 1'b0;
    w_enable_cache =1'b0;   
        w_write_cache  =1'b0;   
    end
    `IAND:
 	 begin 
    w_single_cycle_out =a& b;
    w_status = 1'b0;
    w_enable_cache =1'b0;   
        w_write_cache  =1'b0;   
     end
    `IOR: 
 	 begin 
    w_single_cycle_out =a| b;
    w_status = 1'b0; 
    w_enable_cache =1'b0;   
    w_write_cache  =1'b0;   
     end
     `IXOR: 
 	 begin 
     w_single_cycle_out =a^ b;
     w_status = 1'b0; 
     w_enable_cache =1'b0;   
     w_write_cache  =1'b0;   
      end
       `ISHL: 
 	 begin 
      w_single_cycle_out =a<< b;
      w_status = 1'b0; 
      w_enable_cache =1'b0;   
      w_write_cache  =1'b0;   
       end
          `ISHR: 
 	 begin 
       w_single_cycle_out =a>>> b;
       w_status = 1'b0; 
       w_enable_cache =1'b0;   
       w_write_cache  =1'b0;   
        end  
      `IUSHR: 
 	 begin 
        w_single_cycle_out =a>> b;
        w_status = 1'b0; 
        w_enable_cache =1'b0;   
        w_write_cache  =1'b0;   
     end 
    `DMA_LOAD: 
 	 begin 
    w_single_cycle_out = 0;
    w_status = 1'b0; 
    w_enable_cache = (CONDITIONAL_I) ? PBOX_I : 1'b1;
    w_write_cache  =1'b0;
     end
     `DMA_STORE:  
 	begin 
    w_single_cycle_out = 0;
    w_status = 1'b0; 
    w_enable_cache = (CONDITIONAL_I) ? PBOX_I : 1'b1;
    w_write_cache  =1'b1;
     end
    `IFEQ: 
 	 begin 
     w_single_cycle_out = 0; // can be changed later, if there is an operation that is a good extension
     w_status = (a == b) ? 1'b1 : 1'b0; 
     w_enable_cache =1'b0;
     w_write_cache  =1'b0;
      end
  `IFNE: 
 	 begin 
      w_single_cycle_out = 0; // can be changed later, if there is an operation that is a good extension
      w_status = (a != b) ? 1'b1 : 1'b0; 
      w_enable_cache =1'b0;
      w_write_cache  =1'b0;
       end
  `IFGE: 
 	 begin 
       w_single_cycle_out = 0; // can be changed later, if there is an operation that is a good extension
       w_status = (a >= b) ? 1'b1 : 1'b0; 
       w_enable_cache =1'b0;
       w_write_cache  =1'b0;
        end
     `IFGT: 
 	 begin 
         w_single_cycle_out = 0; // can be changed later, if there is an operation that is a good extension
         w_status = (a > b) ? 1'b1 : 1'b0; 
         w_enable_cache =1'b0;
         w_write_cache  =1'b0;
          end
    `IFLE: 
 	 begin 
        w_single_cycle_out = 0; // can be changed later, if there is an operation that is a good extension
        w_status = (a <= b) ? 1'b1 : 1'b0; 
        w_enable_cache =1'b0;
        w_write_cache  =1'b0;
         end
    `IFLT: 
 	 begin 
       w_single_cycle_out = 0; // can be changed later, if there is an operation that is a good extension
       w_status = (a < b) ? 1'b1 : 1'b0;
       w_enable_cache =1'b0;
       w_write_cache  =1'b0;
        end
    `INEG: 
 	 begin 
       w_single_cycle_out = -a;
       w_status = 1'b0;
       w_enable_cache =1'b0;
       w_write_cache  =1'b0;
        end 
    `NOP  : 
 	 begin 
     w_single_cycle_out = a;
     w_status = 1'b0; 
     w_enable_cache =1'b0;
     w_write_cache  =1'b0;
      end
	default:  
 	begin
	 w_single_cycle_out = 1'b0;
	 w_status = 1'b0;
	 w_enable_cache =1'b0;
     w_write_cache  =1'b0;
    end
  endcase
end


/////////////////////////////////////////////////////
// Multi-cycle operations:
/////////////////////////////////////////////////////
     
   always@(*) begin
   case(OPCODE_I)
   `LADD: 
 	begin
    if(r_counter[0]) begin
      r_multi_cycle_out =a+ b + r_carry;
      w_reminder = 1'b0;
      end
    else begin
       r_multi_cycle_out = {1'b0,a} + {1'b0,b};
      w_reminder = 1'b1;
      end
    end
   `LSUB: 
 	begin
    if(r_counter[0]) begin
      r_multi_cycle_out =a+ ~b + r_carry;
      w_reminder = 1'b0;
      end
    else begin
       r_multi_cycle_out = {1'b0,a} + {1'b0,~b} +1;
      w_reminder = 1'b1;
      end
    end
// stop
   default: begin
       r_multi_cycle_out = 0;
       w_reminder = 1'b0;
     end
   endcase
   end
  
/*
// IMUL    
   wire w_load_block_m;
   assign w_load_block_m = (OPCODE_I == `IMUL && r_counter ==0) ? 1'b1 : 1'b0;

    multiply mul(
	.result(w_mult_result),
	.start(w_load_block_m),
	.multiplier(b),
	.multiplicand(a),
	.sign(1'b1),
	.clk(CLK_I),
	.enable(EN_I)); 

// END IMUL
*/
/////////////////////////////////////////////////////
// output multiplexing:
/////////////////////////////////////////////////////

assign  RESULT_O = (w_single_cycle_operation == 1'b0) ? r_multi_cycle_out[`DATA_WIDTH-1:0] : w_single_cycle_out;


endmodule
