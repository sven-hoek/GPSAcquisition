/*
Author: Dennis L. Wolf
Date: 01.09.2015
Version: 1.1 (topmodule cgra - autogenerated)
Version History: 	1.1 changed to header and `define
			1.0 construct
*/
`include "definitions.vh" // import definitions of parameters and types
`include "AMIDAR_definitions.vh"

module Cgra (
  CLK_I,
  RST_N_I,
  EN_I,
  TOKEN_VALID,
  OPCODE_I,
  DEST_TAG_I,
  DEST_FU_I,
  DEST_PORT_I,
  OPERAND_DATA_I,
  OPERAND_DATA_VALID_I,
  OPERAND_ADDR_I,
  OPERAND_ADDR_VALID_I,
// Cache input list
  CONTEXT_DATA_I,
  CONTEXT_DATA_VALID_I,
  DATA_CONTROLUNIT_I,
  WR_EN_CONTROLUNIT_I,
// Cache output list
  OPERAND_ACK,
  EXCEPTION_O,
  EXCEPTION_ID_O,
  DEST_TAG_O,
  DEST_FU_O,
  DEST_PORT_O,
  RESULT_O,
  RESULT_VALID_O,
  RESULT_ACK_I  
  );

// PORTS:
                          input wire  			CLK_I;
(* dont_touch = "true" *) input wire  				RST_N_I;
(* dont_touch = "true" *) input wire  				EN_I;
(* dont_touch = "true" *) input wire  				TOKEN_VALID;
(* dont_touch = "true" *) input wire [`AMIDAR_OPCODE_WIDTH-1:0]	OPCODE_I;
(* dont_touch = "true" *) input wire [`AMIDAR_TAG_WIDTH-1:0]	DEST_TAG_I;
(* dont_touch = "true" *) input wire [`AMIDAR_FU_ID_WIDTH-1:0]	DEST_FU_I;
(* dont_touch = "true" *) input wire [`AMIDAR_PORT_ID_WIDTH-1:0]DEST_PORT_I;
(* dont_touch = "true" *) input wire [`DATA_WIDTH-1:0]		OPERAND_DATA_I;
(* dont_touch = "true" *) input  wire 				OPERAND_DATA_VALID_I;
(* dont_touch = "true" *) input  wire[`DATA_WIDTH-1:0]		OPERAND_ADDR_I;
(* dont_touch = "true" *) input wire  				OPERAND_ADDR_VALID_I;
// Cache input decleration
// Contxtdata input
(* dont_touch = "true" *) input wire 				CONTEXT_DATA_VALID_I;
(* dont_touch = "true" *) input wire [`CONTEXT_ADDR_WIDTH+1:0] 	DATA_CONTROLUNIT_I;
(* dont_touch = "true" *) input wire WR_EN_CONTROLUNIT_I;
// Cache output decleration
output wire				OPERAND_ACK;
output reg			        EXCEPTION_O;
output reg [`EXCEPTION_WIDTH-1:0]	EXCEPTION_ID_O;
output wire [`AMIDAR_TAG_WIDTH-1:0]	DEST_TAG_O;
output  wire[`AMIDAR_FU_ID_WIDTH-1:0]	DEST_FU_O;
output  wire[`AMIDAR_PORT_ID_WIDTH-1:0] DEST_PORT_O;
output reg [`DATA_WIDTH-1:0]		RESULT_O;
output wire  				RESULT_VALID_O;
 (* dont_touch = "true" *) input  wire 	RESULT_ACK_I;

reg [`STATE_WIDTH-1:0] state,next_state;
reg [`EXCEPTION_WIDTH-1:0] w_exception;
reg w_exception_flag;

wire [`CONTEXT_ADDR_WIDTH-1:0] w_pc;
reg w_save_token;

reg [`CONTEXT_ADDR_WIDTH-1:0] r_counter_load_context;


// FSM - STATE TRANSITIONS 

always@(*) begin
case (state) // open switch - big
 // IDLE STATE
  `IDLE : begin
    if(TOKEN_VALID == 1'b1) begin
     case(OPCODE_I) 
      `OP_WRITECONTEXT:  begin
		      if(OPERAND_DATA_VALID_I==1'b1 && OPERAND_ADDR_VALID_I ==1'b1)
 		       next_state = `WRITECONTEXT;
                       else
 		        next_state = `IDLE;
              w_exception_flag = 1'b0;
		      w_exception = `EXCEPTION_NONE;
		     w_save_token = 1'b0;
		     end
		     
      `OP_LOADPROGRAM: begin
                if(OPERAND_DATA_VALID_I==1'b1 && OPERAND_ADDR_VALID_I ==1'b1)
                next_state = `LOAD_PROGRAM;
                       else
                 next_state = `IDLE;
                w_exception_flag = 1'b0;
                w_exception = `EXCEPTION_NONE;
                w_save_token = 1'b0;
            end
    `OP_WRITELOCALVAR: begin 
             if(OPERAND_DATA_VALID_I==1'b1)
                next_state = `WRITELOCALVAR;
             else
		        next_state = `IDLE;
             w_exception_flag = 1'b0;
		     w_exception = `EXCEPTION_NONE;
		     w_save_token = 1'b0;
		    end

    `OP_RUN: 	    begin 
		     if(OPERAND_ADDR_VALID_I==1'b1)
 		      next_state = `SETADDRESS;
                      else
 		       next_state = `IDLE;
             w_exception_flag = 1'b0;
		     w_exception = `EXCEPTION_NONE;
		     w_save_token = 1'b0;
		    end

     `OP_SEND: 	    begin 
		     next_state = `SENDING;
             w_exception_flag = 1'b0;
		     w_exception =`EXCEPTION_NONE;
		     w_save_token = 1'b1;
		    end
        
      default: begin
       w_exception_flag = 1'b1;
       w_exception = `EXCEPTION_NOT_A_VALID_OPCODE;
       next_state = `IDLE;
       w_save_token = 1'b0;
      end
     endcase    
    end 
    else begin
     next_state = `IDLE;
     w_exception_flag = 1'b0;
     w_exception = `EXCEPTION_NONE;
     w_save_token = 1'b0;
     end
   end

 // WRITECONTEXT STATE
  `WRITECONTEXT : begin 
     next_state = `IDLE;
     w_exception_flag = 1'b0;
     w_exception = `EXCEPTION_NONE;
     w_save_token = 1'b0;
   end // close write context state
   
    `LOAD_PROGRAM_FINISHED:    begin 
          next_state = `IDLE;
          w_exception_flag = 1'b0;
          w_exception =`EXCEPTION_NONE;
          w_save_token = 1'b0;
         end 
         
   `LOAD_PROGRAM: begin
         if(r_counter_load_context == OPERAND_DATA_I[`CONTEXT_ADDR_WIDTH-1:0])
         next_state = `LOAD_PROGRAM_FINISHED;
                else
          next_state = `LOAD_PROGRAM;
         w_exception_flag = 1'b0;
         w_exception = `EXCEPTION_NONE;
         w_save_token = 1'b0;
     end

 // WRITELOCALVAR STATE
  `WRITELOCALVAR : begin
     next_state = `IDLE;
     w_exception_flag = 1'b0;
     w_exception = `EXCEPTION_NONE;
     w_save_token = 1'b0;
     end 

 // SETADDRESS STATE
  `SETADDRESS : begin
     next_state = `RUN;     
     w_exception_flag = 1'b0;
     w_exception = `EXCEPTION_NONE;
     w_save_token = 1'b0;
   end // close set address

 // RUN STATE
  `RUN : begin
     if(w_pc == `CONTEXT_MEMORY_LENGTH-1)
       next_state = `ACK;
     else
	   next_state = `RUN;
     w_exception_flag = 1'b0;
     w_exception = `EXCEPTION_NONE;
     w_save_token = 1'b0;
   end // close run

 // ACK STATE
  `ACK : begin
     next_state = `IDLE;
     w_exception_flag = 1'b0;
     w_exception = `EXCEPTION_NONE;
     w_save_token = 1'b0;
   end // close ack

 // SENDING STATE
  `SENDING : begin
     if(RESULT_ACK_I == 1'b1)
	   next_state = `IDLE;
	 else
	   next_state = `SENDING;
     w_exception_flag = 1'b0;
     w_exception = `EXCEPTION_NONE;
     w_save_token = 1'b0;
   end // close sending

  default : begin  // default
     next_state = `IDLE;
     w_exception_flag = 1'b1;
     w_exception = `EXCEPTION_ENTERED_BAD_STATE;
     w_save_token = 1'b0;
   end // close default
  endcase // // close big switch
end



reg [`AMIDAR_TAG_WIDTH-1:0]	tag_buffer;
reg [`AMIDAR_FU_ID_WIDTH-1:0]	dest_fu_buffer;
reg [`AMIDAR_PORT_ID_WIDTH-1:0]	des_port_buffer;

assign DEST_TAG_O = tag_buffer;
assign DEST_FU_O = dest_fu_buffer;
assign DEST_PORT_O = des_port_buffer;


always@(posedge CLK_I) begin
 if(~RST_N_I) begin
  state <= `IDLE;
  EXCEPTION_O <= 1'b0;
  EXCEPTION_ID_O <= 0;
  tag_buffer <= 0;
  dest_fu_buffer <= 0;
  des_port_buffer <= 0;
  r_counter_load_context <= 0;
 end
  else if(~EN_I)begin
   state <= state;
   EXCEPTION_O <= EXCEPTION_O;
   EXCEPTION_ID_O <= EXCEPTION_ID_O;
   tag_buffer <=  tag_buffer;
   dest_fu_buffer <=  dest_fu_buffer;
   des_port_buffer <= des_port_buffer;
   r_counter_load_context <= r_counter_load_context;
  end
   else begin
    state<=next_state;
    EXCEPTION_O <= w_exception_flag;
    EXCEPTION_ID_O <= w_exception;
    if(state == `IDLE && next_state == `LOAD_PROGRAM)
        r_counter_load_context <= OPERAND_ADDR_I[`CONTEXT_ADDR_WIDTH-1:`PES_ADDR_WIDTH];
    else
    r_counter_load_context <= r_counter_load_context+1;
    if(w_save_token) begin
     tag_buffer <= DEST_TAG_I;
     dest_fu_buffer <= DEST_FU_I;
     des_port_buffer <= DEST_PORT_I;
    end
     else begin
      tag_buffer <=  tag_buffer;
      dest_fu_buffer <=  dest_fu_buffer;
      des_port_buffer <= des_port_buffer;
     end
   end
end


// CONTROL SIGNALS - OUTPUT OF FSM


reg w_operand_acknowledge, w_valid_result;
assign RESULT_VALID_O = w_valid_result;
assign OPERAND_ACK = w_operand_acknowledge;
reg w_load_enable_controlunit;
reg w_enable_submodules;
reg w_enable_controlunit;
reg w_write_context;
reg w_clean_context_127;
reg joint_cache_valids;
reg w_en_contexts;
reg r_context_pc_dependent;

always@(*) begin
// joint cache valid
end



always@(*) begin
 case(state) 
  `IDLE: 	begin
		 w_operand_acknowledge = 1'b0;
		 w_valid_result =1'b0;
		 w_load_enable_controlunit = 1'b0;
		 w_enable_submodules = 1'b0;
		 w_enable_controlunit = 1'b0;
		 w_write_context = 1'b0;
		 w_clean_context_127 = 1'b0;
		 w_en_contexts = EN_I;
		 r_context_pc_dependent = 1'b1;
        	end

  `WRITECONTEXT: begin
		 w_operand_acknowledge = 1'b1;
		 w_valid_result =1'b0;
		 w_load_enable_controlunit = 1'b0;
		 w_enable_submodules = 1'b0;
		 w_enable_controlunit = 1'b0;
		 w_write_context = 1'b1;
		 w_clean_context_127 = 1'b0;
		 w_en_contexts = EN_I;
		 r_context_pc_dependent = 1'b1;
       		end
       		
  `LOAD_PROGRAM: begin
        w_operand_acknowledge = 1'b0;
        w_valid_result =1'b0;
        w_load_enable_controlunit = 1'b0;
        w_enable_submodules = 1'b0;
        w_enable_controlunit = 1'b0;
        w_write_context = 1'b1;
        w_clean_context_127 = 1'b0;
        w_en_contexts = EN_I && CONTEXT_DATA_VALID_I;
        r_context_pc_dependent = 1'b0;
              end
              
    `LOAD_PROGRAM_FINISHED: begin
          w_operand_acknowledge = 1'b1;
          w_valid_result =1'b0;
          w_load_enable_controlunit = 1'b0;
          w_enable_submodules = 1'b0;
          w_enable_controlunit = 1'b0;
          w_write_context = 1'b0;
          w_clean_context_127 = 1'b0;
          w_en_contexts = EN_I;
          r_context_pc_dependent = 1'b0;
             end          
    

  `WRITELOCALVAR: begin
		 w_operand_acknowledge = 1'b1;
		 w_valid_result =1'b0;
		 w_load_enable_controlunit = 1'b0;
		 w_enable_submodules = 1'b1;
		 w_enable_controlunit = 1'b0;
		 w_write_context = 1'b0;
		 w_clean_context_127 = 1'b0;
		 w_en_contexts = EN_I;
		 r_context_pc_dependent = 1'b1;
        	end

  `SETADDRESS: 	begin
		 w_operand_acknowledge = 1'b0;
		 w_valid_result =1'b0;
		 w_load_enable_controlunit = 1'b1;
		 w_enable_submodules = 1'b0;
		 w_enable_controlunit = EN_I;
		 w_write_context = 1'b1;
		 w_clean_context_127 = 1'b1;
		 w_en_contexts = EN_I;
		 r_context_pc_dependent = 1'b1;
        	end

  `RUN: 		begin
		 w_operand_acknowledge = 1'b0;
		 w_valid_result =1'b0;
		 w_load_enable_controlunit = 1'b0;
		 w_enable_submodules = EN_I & joint_cache_valids;
		 w_enable_controlunit = EN_I & joint_cache_valids;
		 w_write_context = 1'b0;
		 w_clean_context_127 = 1'b0;
		 w_en_contexts = EN_I;
		 r_context_pc_dependent = 1'b1;
           	end

  `ACK: 	begin
		 w_operand_acknowledge = 1'b1;
		 w_valid_result =1'b0;
		 w_load_enable_controlunit = 1'b0;
		 w_enable_submodules = 1'b0;
		 w_enable_controlunit = 1'b0;
		 w_write_context = 1'b0;
		 w_clean_context_127 = 1'b0;
		 w_en_contexts = EN_I;
		 r_context_pc_dependent = 1'b1;
           	end

  `SENDING: 	begin
		 w_operand_acknowledge = 1'b1;
		 w_valid_result =1'b1;
		 w_load_enable_controlunit = 1'b0;
		 w_enable_submodules = 1'b1;
		 w_enable_controlunit = 1'b0;
		 w_write_context = 1'b0;
		 w_clean_context_127 = 1'b0;
		 w_en_contexts = EN_I;
		 r_context_pc_dependent = 1'b1;
           	end
   default:begin
        w_operand_acknowledge = 1'b0;
        w_valid_result =1'b0;
        w_load_enable_controlunit = 1'b0;
        w_enable_submodules = 1'b0;
        w_enable_controlunit = 1'b0;
        w_write_context = 1'b0;
        w_clean_context_127 = 1'b0;
        w_en_contexts = EN_I;
        r_context_pc_dependent = 1'b0;
              end 
 endcase

end

// data to context constructs
wire [`CONTEXT_WIDTH-1:0] w_context_in [`NR_OF_PES-1:0];
wire [`NR_OF_PES-1:0] w_write_context_single;
wire [`CONTEXT_WIDTH-1:0] w_context_mapped_data;

assign w_context_mapped_data[`en_pe]= 1'b1;
assign w_context_mapped_data[`cond_dma_pe]= 0;
assign w_context_mapped_data[`cond_wr_pe]= 0;
assign w_context_mapped_data[`wr_en_pe]= OPERAND_DATA_I[`bus_wr_en];
assign w_context_mapped_data[`rdmuxH_pe:`rdmuxL_pe]= OPERAND_DATA_I[`bus_rdmuxH:`bus_rdmuxL];
assign w_context_mapped_data[`rddoH_pe:`rddoL_pe]= 0;
assign w_context_mapped_data[`rdCacheH_pe:`rdCacheL_pe]= 0;
assign w_context_mapped_data[`wrH_pe:`wrL_pe]= OPERAND_DATA_I[`bus_wrH:`bus_wrL];
assign w_context_mapped_data[`muxAH_pe:`muxAL_pe]= 0;
assign w_context_mapped_data[`muxBH_pe:`muxBL_pe]= OPERAND_DATA_I[`bus_muxBH:`bus_muxBL];
assign w_context_mapped_data[`muxRegH_pe:`muxRegL_pe]= OPERAND_DATA_I[`bus_muxRegH:`bus_muxRegL];
assign w_context_mapped_data[`opH_pe:`opL_pe]= 0;

//wire [`CONTEXT_WIDTH-1:0] w_converted_context_inputs;



wire [`CONTEXT_WIDTH_PBOX-1:0] w_context_pbox_in;

genvar i;
generate
    for(i=0; i <`NR_OF_PES; i=i+1)
      assign w_context_in[i] = 	(w_clean_context_127 == 1'b1) ? {`CONTEXT_WIDTH{1'b0}} : (r_context_pc_dependent == 1'b0) ? 
// data 2 context pe
				CONTEXT_DATA_I 
				: (i == OPERAND_ADDR_I[`PES_ADDR_WIDTH-1:0]) ? w_context_mapped_data : 0;
endgenerate

genvar t;
generate
    for(t=0; t <`NR_OF_PES; t=t+1)
assign w_write_context_single[t] = ((!r_context_pc_dependent) && (t != OPERAND_ADDR_I[`PES_ADDR_WIDTH-1:0])) ? 1'b0 : w_write_context;
endgenerate

wire [`DATA_WIDTH-1:0] w_out_pe [`NR_OF_PES-1:0];
assign w_context_pbox_in = 	(w_clean_context_127 == 1'b1) ? {`CONTEXT_WIDTH_PBOX{1'b0}}: (r_context_pc_dependent == 1'b0) ? 
// data 2 context cbox
				CONTEXT_DATA_I
				:(OPERAND_ADDR_I[`PES_ADDR_WIDTH-1:0] == `NR_OF_PES) ? CONTEXT_DATA_I[`CONTEXT_WIDTH_PBOX-1:0] : 0; // last statement is bullshit but necessary for full synthesis


always@(*)begin
 case(OPERAND_ADDR_I[`PES_ADDR_WIDTH-1:0])
// result connection
 default: RESULT_O = 0;
 endcase
 end


// Initialize controlunit :

wire w_pbox_2_controlunit;

Controlunit controlunit (
  .CLK_I(CLK_I),
//  .RST_N_I(RST_N_I),
  .EN_I(w_enable_controlunit),
  .CBOX_I(w_pbox_2_controlunit),
  .DATA_I(DATA_CONTROLUNIT_I),
  .ADDR_I(OPERAND_ADDR_I[`CONTEXT_ADDR_WIDTH-1:0]),
  .WR_EN_I(WR_EN_CONTROLUNIT_I),
  .LOAD_EN_I(w_load_enable_controlunit),
  .PC_O(w_pc)
  );

// wires pe 2 cbox
wire [`CONTEXT_WIDTH_PBOX-1:0] w_pboxcontext;
wire w_status_pbox_2_pes;

wire[`CONTEXT_ADDR_WIDTH-1:0] w_context_wr_addr =(w_clean_context_127 == 1'b1) ? {`CONTEXT_WIDTH_PBOX{1'b1}}:  (r_context_pc_dependent == 1'b1) ? w_pc : r_counter_load_context;



wire [`CONTEXT_WIDTH-1:0] w_context [`NR_OF_PES-1:0];


generate
genvar k;
     for(k=0;k<`NR_OF_PES;k=k+1) begin : PE
	Context context(
  	.CLK_I(CLK_I),
//  	.RST_N_I(RST_N_I),
  	.EN_I(joint_cache_valids),
  	.PC_I(w_pc),
  	.DATA_I(w_context_in[k]),
  	.WR_ADDR_I(w_context_wr_addr),
  	.WR_EN_I(w_write_context_single[k]),
  	.DATA_O(w_context[k])
   	);
     end
endgenerate

wire [`DATA_WIDTH-1:0] w_data_o [`NR_OF_PES-1:0];

wire w_write_context_cbox;

assign w_write_context_cbox = w_write_context &( !w_clean_context_127);


// Pe generation

   Context_pbox context_pbox(
     .CLK_I(CLK_I),
//     .RST_N_I(RST_N_I),
     .EN_I(joint_cache_valids),
     .PC_I(w_pc),
     .DATA_I(w_context_pbox_in),
     .WR_ADDR_I(w_context_wr_addr),
     .WR_EN_I(w_write_context_cbox),
     .DATA_O(w_pboxcontext)
      );
   
   
   PBox_new magical(
     .CLK_I(CLK_I),
     .RST_N_I(RST_N_I),
     .EN_I(w_enable_submodules),
// pbox status inputs
     .CONTEXT_FULL_I(w_pboxcontext),
     .Reg_O(w_status_pbox_2_pes),
     .Comb_O(w_pbox_2_controlunit)
            
     );

endmodule
  
